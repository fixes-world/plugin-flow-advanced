{"version":3,"sources":["../src/actions/transfer.ts","../src/helpers/formater.ts","../src/services/acctPool.service.ts","../src/assets/cadence/scripts/get_flow_price.cdc","../src/assets/cadence/scripts/get_stflow_price.cdc","../src/assets/cadence/scripts/get_flow_token_info.cdc","../src/assets/cadence/scripts/get_erc20_token_info.cdc","../src/assets/cadence/scripts/account-pool/is_address_child_of_main.cdc","../src/assets/cadence/scripts/account-pool/get_acct_info_from.cdc","../src/assets/cadence/scripts/account-pool/get_acct_status.cdc","../src/assets/cadence/scripts/token-list/is-token-registered.cdc","../src/assets/cadence/scripts/token-list/is-evm-asset-registered.cdc","../src/assets/scripts.defs.ts","../src/assets/cadence/transactions/init_agent_account.cdc","../src/assets/cadence/transactions/account-pool/create_child.cdc","../src/assets/cadence/transactions/account-pool/evm/transfer_erc20_from.cdc","../src/assets/cadence/transactions/account-pool/flow-token/dynamic_vm_transfer_from.cdc","../src/assets/cadence/transactions/account-pool/ft/generic_transfer_with_address_from.cdc","../src/assets/cadence/transactions/account-pool/token-list/register_evm_asset_from.cdc","../src/assets/cadence/transactions/account-pool/token-list/register_standard_asset_from.cdc","../src/assets/cadence/transactions/token-list/register_standard_asset_no_bridge.cdc","../src/assets/transactions.defs.ts","../src/actions/get-flow-price.ts","../src/actions/get-token-info.ts","../src/actions/ensure-user-account-exists.ts","../src/actions/ensure-token-registered.ts","../src/plugin.ts","../src/providers/account.provider.ts","../src/index.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { inject, injectable } from \"inversify\";\nimport {\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { type ActionOptions, globalContainer, property } from \"@elizaos-plugins/plugin-di\";\nimport { isCadenceIdentifier, isEVMAddress, isFlowAddress, BaseFlowInjectableAction } from \"@elizaos-plugins/plugin-flow\";\nimport { formater } from \"../helpers\";\n\nimport { AccountsPoolService } from \"../services/acctPool.service\";\n\n/**\n * The generated content for the transfer action\n */\nexport class TransferContent {\n    @property({\n        description:\n            \"Cadence Resource Identifier or ERC20 contract address (if not native token). this field should be null if the token is native token: $FLOW or FLOW\",\n        examples: [\n            \"For Cadence resource identifier, the field should be 'A.1654653399040a61.ContractName'\",\n            \"For ERC20 contract address, the field should be '0xe6ffc15a5bde7dd33c127670ba2b9fcb82db971a'\",\n        ],\n        schema: z.string().nullable(),\n    })\n    token: string | null;\n\n    @property({\n        description: \"Amount to transfer, it should be a number or a string\",\n        examples: [\"'1000'\", \"1000\"],\n        schema: z.union([z.string(), z.number()]),\n    })\n    amount: string;\n\n    @property({\n        description:\n            \"Recipient identifier, can a wallet address like EVM address or Cadence address, or a userId which is UUID formated.\",\n        examples: [\n            \"For Cadence address: '0x1654653399040a61'\",\n            \"For EVM address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'\",\n            \"For userId: 'e1b3b9c2-7e3f-4b1b-9f7d-2a0c7e2d6e9c', If the recipient mentioned in message is 'me' or 'myself', it should be the current user's id\",\n        ],\n        schema: z.string(),\n    })\n    to: string;\n}\n\n/**\n * The transfer action options\n */\nconst transferOption: ActionOptions<TransferContent> = {\n    name: \"SEND_COIN\",\n    similes: [\n        \"SEND_TOKEN\",\n        \"SEND_TOKEN_ON_FLOW\",\n        \"TRANSFER_TOKEN_ON_FLOW\",\n        \"TRANSFER_TOKENS_ON_FLOW\",\n        \"TRANSFER_FLOW\",\n        \"SEND_FLOW\",\n        \"PAY_BY_FLOW\",\n    ],\n    description:\n        \"Call this action to transfer any fungible token/coin from the user's Flow wallet to another address\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1 FLOW to 0xa2de93114bae3e73\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1 FLOW - A.1654653399040a61.FlowToken to 0xa2de93114bae3e73\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1000 FROTH - 0xb73bf8e6a4477a952e0338e6cc00cc0ce5ad04ba to 0x000000000000000000000002e44fbfbd00395de5\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: \"I need to send 1 FLOW to user: {{user1}}\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n    ],\n    contentClass: TransferContent,\n    suppressInitialMessage: true,\n};\n\n/**\n * Check if a string is a valid UUID\n * @param str The string to check\n * @returns true if the string is a valid UUID\n */\nfunction isUUID(str: string): boolean {\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    return uuidRegex.test(str);\n}\n\n/**\n * Transfer action\n *\n * @category Actions\n * @description Transfer funds from one account to another\n */\n@injectable()\nexport class TransferAction extends BaseFlowInjectableAction<TransferContent> {\n    constructor(\n        @inject(AccountsPoolService)\n        private readonly acctPoolService: AccountsPoolService,\n    ) {\n        super(transferOption);\n    }\n\n    /**\n     * Validate the transfer action\n     * @param runtime the runtime instance\n     * @param message the message content\n     * @param state the state object\n     */\n    async validate(runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> {\n        if (await super.validate(runtime, message, state)) {\n            // TODO: Add custom validation logic here to ensure the transfer does not come from unauthorized sources\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Execute the transfer action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async execute(\n        content: TransferContent | null,\n        _runtime: IAgentRuntime,\n        message: Memory,\n        _state?: State,\n        callback?: HandlerCallback,\n    ) {\n        if (!content) {\n            elizaLogger.warn(\"No content generated\");\n            return;\n        }\n\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        // Use main account of the agent\n        const walletAddress = this.walletSerivce.address;\n\n        // Get the user id\n        const userId = message.userId;\n        const isSelf = userId === message.agentId;\n        const logPrefix = `Account[${walletAddress}/${isSelf ? \"root\" : userId}]`;\n\n        // Parsed fields\n        const amount =\n            typeof content.amount === \"number\" ? content.amount : Number.parseFloat(content.amount);\n\n        try {\n            let recipient = content.to;\n            // Check if the recipient is a user id\n            if (isUUID(content.to)) {\n                if (content.to === userId) {\n                    // You can't send to yourself\n                    throw new Error(\"Recipient is the same as the sender\");\n                }\n\n                // Get the wallet address of the user\n                const acctInfo = await this.acctPoolService.queryAccountInfo(content.to);\n                if (acctInfo) {\n                    recipient = acctInfo.address;\n                    elizaLogger.info(\n                        `${logPrefix}\\n Recipient is a user id - ${content.to}, its wallet address: ${recipient}`,\n                    );\n                } else {\n                    throw new Error(`Recipient not found with id: ${content.to}`);\n                }\n            }\n\n            let txId: string;\n            let keyIndex: number;\n\n            // For different token types, we need to handle the token differently\n            if (!content.token) {\n                // Check if the wallet has enough balance to transfer\n                const fromAccountInfo = await this.acctPoolService.queryAccountInfo(userId);\n                const totalBalance = fromAccountInfo.balance + (fromAccountInfo.coaBalance ?? 0);\n\n                // Check if the amount is valid\n                if (totalBalance < amount) {\n                    throw new Error(\"Insufficient balance to transfer\");\n                }\n\n                elizaLogger.log(`${logPrefix}\\n Sending ${amount} FLOW to ${recipient}...`);\n                // Transfer FLOW token\n                const resp = await this.acctPoolService.transferFlowToken(\n                    userId,\n                    recipient,\n                    amount,\n                );\n                txId = resp.txId;\n                keyIndex = resp.index;\n            } else if (isCadenceIdentifier(content.token)) {\n                if (!isFlowAddress(recipient)) {\n                    throw new Error(\"Recipient address is not a valid Flow address\");\n                }\n\n                // Transfer Fungible Token on Cadence side\n                const [_, tokenAddr, tokenContractName] = content.token.split(\".\");\n                elizaLogger.log(\n                    `${logPrefix}\\n Sending ${amount} A.${tokenAddr}.${tokenContractName} to ${recipient}...`,\n                );\n                const resp = await this.acctPoolService.transferGenericFT(\n                    userId,\n                    recipient,\n                    amount,\n                    `0x${tokenAddr}`,\n                    tokenContractName,\n                );\n                txId = resp.txId;\n                keyIndex = resp.index;\n            } else if (isEVMAddress(content.token)) {\n                if (!isEVMAddress(recipient)) {\n                    throw new Error(\"Recipient address is not a valid EVM address\");\n                }\n\n                elizaLogger.log(\n                    `${logPrefix}\\n Sending ${amount} ${content.token}(EVM) to ${recipient}...`,\n                );\n\n                // Transfer ERC20 token on EVM side\n                const resp = await this.acctPoolService.transferERC20(\n                    userId,\n                    recipient,\n                    amount,\n                    content.token,\n                );\n                txId = resp.txId;\n                keyIndex = resp.index;\n            }\n\n            elizaLogger.log(`${logPrefix}\\n Sent transaction: ${txId} by KeyIndex[${keyIndex}]`);\n\n            // call the callback with the transaction response\n            if (callback) {\n                const tokenName = content.token || \"FLOW\";\n                const extraMsg = `${logPrefix}\\n Successfully transferred ${content.amount} ${tokenName} to ${content.to}`;\n                callback?.({\n                    text: formater.formatTransationSent(txId, this.walletSerivce.wallet.network, extraMsg),\n                    content: {\n                        success: true,\n                        txid: txId,\n                        token: content.token,\n                        to: content.to,\n                        amount: content.amount,\n                    },\n                });\n            }\n        } catch (e) {\n            elizaLogger.error(\"Error in sending transaction:\", e.message);\n            callback?.({\n                text: `${logPrefix}\\n Unable to process transfer request. Error: \\n ${e.message}`,\n                content: {\n                    error: e.message,\n                },\n            });\n        }\n\n        elizaLogger.log(`Finished ${this.name} handler.`);\n    }\n}\n\n// Register the transfer action\nglobalContainer.bind(TransferAction).toSelf();\n","import {\n    formatAgentWalletInfo,\n    formatWalletCreated,\n    formatWalletInfo,\n    formatFlowSpent,\n    formatTransationSent\n} from \"@elizaos-plugins/plugin-flow\";\n\nexport {\n    formatAgentWalletInfo,\n    formatWalletCreated,\n    formatWalletInfo,\n    formatFlowSpent,\n    formatTransationSent\n};\n","import { injectable, inject } from \"inversify\";\nimport { elizaLogger, Service, type ServiceType, type IAgentRuntime } from \"@elizaos/core\";\nimport { globalContainer } from \"@elizaos-plugins/plugin-di\";\nimport {\n    FlowWalletService,\n    queries as defaultQueries,\n    type FlowAccountBalanceInfo,\n    type TransactionCallbacks,\n    type TransactionSentResponse,\n} from \"@elizaos-plugins/plugin-flow\";\n\nimport { scripts } from \"../assets/scripts.defs\";\nimport { transactions } from \"../assets/transactions.defs\";\n\n// Add SAMPLE to ServiceType enum in types.ts\ndeclare module \"@elizaos/core\" {\n    export enum ServiceType {\n        ACCOUNTS_POOL = \"accounts-pool\",\n    }\n}\n\n/**\n * Wallet provider\n */\n@injectable()\nexport class AccountsPoolService extends Service {\n    constructor(\n        @inject(FlowWalletService)\n        private readonly walletService: FlowWalletService,\n    ) {\n        super();\n    }\n\n    static get serviceType(): ServiceType {\n        return \"accounts-pool\" as ServiceType.ACCOUNTS_POOL;\n    }\n\n    async initialize(_runtime: IAgentRuntime): Promise<void> {\n        // ensure agent account initialized\n        const status = await this.getMainAccountStatus();\n        if (!status) {\n            // Register the main account\n            await new Promise<void>((resolve, reject) => {\n                this.walletService\n                    .sendTransaction(transactions.initAgentAccount, (_arg, _t) => [], {\n                        onFinalized: async (txid, _status, errorMsg) => {\n                            if (errorMsg) {\n                                elizaLogger.error(`Failed to initialize main account: ${errorMsg}`);\n                                reject(new Error(errorMsg));\n                            } else {\n                                elizaLogger.info(\"Main account initialized by txid:\", txid);\n                                resolve();\n                            }\n                        },\n                    })\n                    .catch(reject);\n            });\n        }\n    }\n\n    // ----- Customized methods -----\n\n    /**\n     * Get the main address of the wallet\n     */\n    get mainAddress(): string {\n        return this.walletService.address;\n    }\n\n    // ----- Flow blockchain READ scripts -----\n\n    /**\n     * Get the main account status\n     */\n    async getMainAccountStatus() {\n        const walletAddress = this.walletService.address;\n        try {\n            const obj = await this.walletService.executeScript(\n                scripts.getAccountStatus,\n                (arg, t) => [arg(walletAddress, t.Address)],\n                undefined,\n            );\n            if (obj) {\n                return {\n                    address: obj.address,\n                    balance: Number.parseFloat(obj.balance),\n                    childrenAmount: Number.parseInt(obj.childrenAmount),\n                };\n            }\n        } catch (error) {\n            elizaLogger.error(`Failed to query account status from ${walletAddress}`, error);\n            throw error;\n        }\n        return undefined;\n    }\n\n    /**\n     * Check if the address is a child of the agent\n     * @param address\n     */\n    async checkAddressIsChildOfAgent(address: string): Promise<boolean> {\n        const walletAddress = this.walletService.address;\n        try {\n            return await this.walletService.executeScript(\n                scripts.isAddressChildOf,\n                (arg, t) => [arg(walletAddress, t.Address), arg(address, t.Address)],\n                false,\n            );\n        } catch (error) {\n            elizaLogger.error(`Failed to check if address ${address} is child of agent`, error);\n        }\n        return false;\n    }\n\n    /**\n     * Query account info\n     * @param userId\n     * @returns\n     */\n    async queryAccountInfo(\n        userId: string = undefined,\n    ): Promise<FlowAccountBalanceInfo | undefined> {\n        const walletAddress = this.walletService.address;\n        try {\n            const obj = await this.walletService.executeScript(\n                scripts.getAccountInfoFrom,\n                (arg, t) => [\n                    arg(walletAddress, t.Address),\n                    arg(userId ?? null, t.Optional(t.String)),\n                ],\n                undefined,\n            );\n            if (obj) {\n                return {\n                    address: obj.address,\n                    balance: Number.parseFloat(obj.balance),\n                    coaAddress: obj.coaAddress,\n                    coaBalance: obj.coaBalance ? Number.parseFloat(obj.coaBalance) : 0,\n                };\n            }\n        } catch (error) {\n            elizaLogger.error(\n                `Failed to query account info for ${userId ?? \"root\"} from ${walletAddress}`,\n                error,\n            );\n            throw error;\n        }\n        return undefined;\n    }\n\n    // ----- Flow blockchain WRITE transactions -----\n\n    /**\n     * Create a new account\n     * @param userId\n     * @returns\n     */\n    async createNewAccount(\n        userId: string,\n        callbacks?: TransactionCallbacks,\n        initalFunding?: number,\n    ): Promise<TransactionSentResponse> {\n        return await this.walletService.sendTransaction(\n            transactions.acctPoolCreateChildAccount,\n            (arg, t) => [\n                arg(userId, t.String),\n                arg(initalFunding ? initalFunding.toFixed(8) : null, t.Optional(t.UFix64)),\n            ],\n            callbacks,\n        );\n    }\n\n    /**\n     * Transfer FlowToken to another account from the user's account\n     * @param fromUserId\n     */\n    async transferFlowToken(\n        fromUserId: string,\n        recipient: string,\n        amount: number,\n        callbacks?: TransactionCallbacks,\n    ): Promise<TransactionSentResponse> {\n        return await this.walletService.sendTransaction(\n            transactions.acctPoolFlowTokenDynamicTransfer,\n            (arg, t) => [\n                arg(recipient, t.String),\n                arg(amount.toFixed(8), t.UFix64),\n                arg(fromUserId, t.Optional(t.String)),\n            ],\n            callbacks,\n        );\n    }\n\n    /**\n     * Transfer Cadence Generic FT to another account from the user's account\n     * @param fromUserId\n     * @param recipient\n     * @param amount\n     * @param tokenFTAddr\n     * @param tokenContractName\n     * @param callbacks\n     */\n    async transferGenericFT(\n        fromUserId: string,\n        recipient: string,\n        amount: number,\n        tokenFTAddr: string,\n        tokenContractName: string,\n        callbacks?: TransactionCallbacks,\n    ): Promise<TransactionSentResponse> {\n        return await this.walletService.sendTransaction(\n            transactions.acctPoolFTGenericTransfer,\n            (arg, t) => [\n                arg(amount.toFixed(8), t.UFix64),\n                arg(recipient, t.Address),\n                arg(tokenFTAddr, t.Address),\n                arg(tokenContractName, t.String),\n                arg(fromUserId, t.Optional(t.String)),\n            ],\n            callbacks,\n        );\n    }\n\n    /**\n     * Transfer ERC20 token to another account from the user's account\n     * @param fromUserId\n     * @param recipient\n     * @param amount\n     * @param callback\n     */\n    async transferERC20(\n        fromUserId: string,\n        recipient: string,\n        amount: number,\n        erc20Contract: string,\n        callbacks?: TransactionCallbacks,\n    ): Promise<TransactionSentResponse> {\n        // Transfer ERC20 token on EVM side\n        // we need to update the amount to be in the smallest unit\n        const decimals = await defaultQueries.queryEvmERC20Decimals(\n            this.walletService.wallet,\n            erc20Contract,\n        );\n        const adjustedAmount = BigInt(amount * 10 ** decimals);\n        return await this.walletService.sendTransaction(\n            transactions.acctPoolEVMTransferERC20,\n            (arg, t) => [\n                arg(erc20Contract, t.String),\n                arg(recipient, t.String),\n                arg(adjustedAmount.toString(), t.UInt256),\n                arg(fromUserId, t.Optional(t.String)),\n            ],\n            callbacks,\n        );\n    }\n}\n\n// Register the provider with the global container\nglobalContainer.bind(AccountsPoolService).toSelf().inSingletonScope();\n","import \"AddressUtils\"\nimport \"PublicPriceOracle\"\n\naccess(all)\nfun main(): UFix64 {\n    let network = AddressUtils.currentNetwork()\n    // reference: https://docs.increment.fi/protocols/decentralized-price-feed-oracle/deployment-addresses\n    var oracleAddress: Address? = nil\n    if network == \"MAINNET\" {\n        oracleAddress = Address.fromString(\"0x\".concat(\"e385412159992e11\"))\n    } else if network == \"TESTNET\" {\n        oracleAddress = Address.fromString(\"0x\".concat(\"cbdb5a7b89c3c844\"))\n    } else {\n        return 1.0\n    }\n    return PublicPriceOracle.getLatestPrice(oracleAddr: oracleAddress!)\n}\n","import \"AddressUtils\"\nimport \"PublicPriceOracle\"\n\naccess(all)\nfun main(): UFix64 {\n    let network = AddressUtils.currentNetwork()\n    // reference: https://docs.increment.fi/protocols/decentralized-price-feed-oracle/deployment-addresses\n    var oracleAddress: Address? = nil\n    if network == \"MAINNET\" {\n        oracleAddress = Address.fromString(\"0x\".concat(\"031dabc5ba1d2932\"))\n    } else {\n        return 1.0\n    }\n    return PublicPriceOracle.getLatestPrice(oracleAddr: oracleAddress!)\n}\n","import \"SwapFactory\"\nimport \"SwapConfig\"\nimport \"SwapInterfaces\"\nimport \"FlowToken\"\nimport \"FungibleToken\"\nimport \"FungibleTokenMetadataViews\"\n\naccess(all)\nfun main(\n    address: Address,\n    contractName: String\n): TokenInfo? {\n    if let ftContract = getAccount(address).contracts.borrow<&{FungibleToken}>(name: contractName) {\n        let totalSupply = ftContract.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.TotalSupply>()) as! FungibleTokenMetadataViews.TotalSupply?\n        if let tokenKey = getFTKey(address, contractName) {\n            if let pairRef = borrowSwapPairRef(tokenKey) {\n                let priceInFLOW = getSwapEstimatedAmountIn(tokenKey: tokenKey, pairRef: pairRef, amount: 1.0)\n                return TokenInfo(\n                    address: address,\n                    contractName: contractName,\n                    totalSupply: totalSupply?.supply ?? 0.0,\n                    priceInFLOW: priceInFLOW\n                )\n            }\n        }\n        return TokenInfo(address: address, contractName: contractName, totalSupply: totalSupply?.supply ?? 0.0, priceInFLOW: 0.0)\n    }\n    return nil\n}\n\naccess(all)\nview fun getFTKey(_ address: Address, _ contractName: String): String? {\n    let addrStr = address.toString()\n    let addrStrNo0x = addrStr.slice(from: 2, upTo: addrStr.length)\n    if let tokenVaultType = CompositeType(\"A.\".concat(addrStrNo0x).concat(\".\").concat(contractName).concat(\".Vault\")) {\n        return SwapConfig.SliceTokenTypeIdentifierFromVaultType(vaultTypeIdentifier: tokenVaultType.identifier)\n    } else {\n        return nil\n    }\n}\n\n/// Borrow the swap pair reference\n///\naccess(all)\nview fun borrowSwapPairRef(_ token0Key: String): &{SwapInterfaces.PairPublic}? {\n    let token1Key = SwapConfig.SliceTokenTypeIdentifierFromVaultType(vaultTypeIdentifier: Type<@FlowToken.Vault>().identifier)\n    if let pairAddr = SwapFactory.getPairAddress(token0Key: token0Key, token1Key: token1Key) {\n        // ensure the pair's contract exists\n        let acct = getAccount(pairAddr)\n        let allNames = acct.contracts.names\n        if !allNames.contains(\"SwapPair\") {\n            return nil\n        }\n\n        // Now we can borrow the reference\n        return acct\n            .capabilities.get<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath)\n            .borrow()\n    }\n    return nil\n}\n\n/// Get the swap pair reserved info for the liquidity pool\n/// 0 - Token0 reserve\n/// 1 - Token1 reserve\n/// 2 - LP token supply\n///\naccess(all)\nview fun getSwapPairReservedInfo(\n    tokenKey: String,\n    pairRef: &{SwapInterfaces.PairPublic},\n): [UFix64; 3]? {\n    let pairInfo = pairRef.getPairInfo()\n\n    var reserve0 = 0.0\n    var reserve1 = 0.0\n    if tokenKey == (pairInfo[0] as! String) {\n        reserve0 = (pairInfo[2] as! UFix64)\n        reserve1 = (pairInfo[3] as! UFix64)\n    } else {\n        reserve0 = (pairInfo[3] as! UFix64)\n        reserve1 = (pairInfo[2] as! UFix64)\n    }\n    let lpTokenSupply = pairInfo[5] as! UFix64\n    return [reserve0, reserve1, lpTokenSupply]\n}\n\n/// Get the estimated swap amount by amount in\n///\naccess(all)\nview fun getSwapEstimatedAmountIn(\n    tokenKey: String,\n    pairRef: &{SwapInterfaces.PairPublic},\n    amount: UFix64,\n): UFix64 {\n    let pairInfo = getSwapPairReservedInfo(tokenKey: tokenKey, pairRef: pairRef)\n    if pairInfo == nil {\n        return 0.0\n    }\n    let reserveToken = pairInfo![0]\n    let reserveFlow = pairInfo![1]\n\n    if reserveToken == 0.0 || reserveFlow == 0.0 {\n        return 0.0\n    }\n\n    return SwapConfig.getAmountIn(amountOut: amount, reserveIn: reserveFlow, reserveOut: reserveToken)\n}\n\naccess(all)\nstruct TokenInfo {\n    access(all)\n    let address: Address\n    access(all)\n    let contractName: String\n    access(all)\n    let totalSupply: UFix64\n    access(all)\n    let priceInFLOW: UFix64\n\n    init(\n        address: Address,\n        contractName: String,\n        totalSupply: UFix64,\n        priceInFLOW: UFix64\n    ) {\n        self.address = address\n        self.contractName = contractName\n        self.totalSupply = totalSupply\n        self.priceInFLOW = priceInFLOW\n    }\n}\n","import \"EVM\"\nimport \"FlowEVMBridgeUtils\"\nimport \"FlowEVMBridgeConfig\"\n\naccess(all)\nfun main(\n    erc20Address: String,\n): TokenInfo? {\n    let ftAddr = EVM.addressFromString(erc20Address)\n    if FlowEVMBridgeUtils.isERC20(evmContractAddress: ftAddr) {\n        let name  = FlowEVMBridgeUtils.getName(evmContractAddress: ftAddr)\n        let symbol = FlowEVMBridgeUtils.getSymbol(evmContractAddress: ftAddr)\n        let decimals = FlowEVMBridgeUtils.getTokenDecimals(evmContractAddress: ftAddr)\n        let totalSupply = FlowEVMBridgeUtils.totalSupply(evmContractAddress: ftAddr)\n\n        // From https://kittypunch.gitbook.io/kittypunch-docs/litterbox/punchswap\n        let punchSwapFactoryAddress = EVM.addressFromString(\"29372c22459a4e373851798bFd6808e71EA34A71\".toLower())\n        // let punchSwapRouterAddress = EVM.addressFromString(\"f45AFe28fd5519d5f8C1d4787a4D5f724C0eFa4d\".toLower())\n        // From https://evm.flowscan.io/token/0xd3bF53DAC106A0290B0483EcBC89d40FcC961f3e\n        let wflowAddress = EVM.addressFromString(\"d3bF53DAC106A0290B0483EcBC89d40FcC961f3e\".toLower())\n\n        let bridgeCOA = borrowCOA()\n\n        // result variables\n        var pairAddress: String? = nil\n        var reservedTokenInPair: UInt128 = 0\n        var reservedFlowInPair: UInt128 = 0\n\n        // Get the pair address\n        let pairAddressRes = bridgeCOA.call(\n            to: punchSwapFactoryAddress,\n            data: EVM.encodeABIWithSignature(\"getPair(address,address)\", [wflowAddress, ftAddr]),\n            gasLimit: FlowEVMBridgeConfig.gasLimit,\n            value: EVM.Balance(attoflow: 0)\n        )\n        if pairAddressRes.status == EVM.Status.successful {\n            let decodedCallResult = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: pairAddressRes.data)\n            if decodedCallResult.length == 1 {\n                let pairAddr = decodedCallResult[0] as! EVM.EVMAddress\n                pairAddress = \"0x\".concat(pairAddr.toString())\n\n                // Get the reserve of the pair\n                let reservesRes = bridgeCOA.call(\n                    to: pairAddr,\n                    data: EVM.encodeABIWithSignature(\"getReserves()\", []),\n                    gasLimit: FlowEVMBridgeConfig.gasLimit,\n                    value: EVM.Balance(attoflow: 0)\n                )\n\n                // Get the token0 of the pair\n                let token0Res = bridgeCOA.call(\n                    to: pairAddr,\n                    data: EVM.encodeABIWithSignature(\"token0()\", []),\n                    gasLimit: FlowEVMBridgeConfig.gasLimit,\n                    value: EVM.Balance(attoflow: 0)\n                )\n\n                if reservesRes.status == EVM.Status.successful && token0Res.status == EVM.Status.successful {\n                    let decodedReservesResult = EVM.decodeABI(types: [Type<UInt128>(), Type<UInt128>(), Type<UInt32>()], data: reservesRes.data)\n                    let decodedToken0Result = EVM.decodeABI(types: [Type<EVM.EVMAddress>()], data: token0Res.data)\n\n                    let token0Addr = decodedToken0Result[0] as! EVM.EVMAddress\n                    let isToken0FT = token0Addr.toString() == ftAddr.toString()\n                    reservedTokenInPair = isToken0FT ? decodedReservesResult[0] as! UInt128 : decodedReservesResult[1] as! UInt128\n                    reservedFlowInPair = isToken0FT ? decodedReservesResult[1] as! UInt128 : decodedReservesResult[0] as! UInt128\n                }\n            }\n        }\n\n        return TokenInfo(\n            address: erc20Address,\n            name: name,\n            symbol: symbol,\n            decimals: decimals,\n            totalSupply: totalSupply,\n            pairAddress: pairAddress,\n            reservedTokenInPair: reservedTokenInPair,\n            reservedFlowInPair: reservedFlowInPair\n        )\n    }\n    return nil\n}\n\n/// Enables other bridge contracts to orchestrate bridge operations from contract-owned COA\n///\naccess(all)\nview fun borrowCOA(): auth(EVM.Call) &EVM.CadenceOwnedAccount {\n    let vmBridgeAddr = Address.fromString(\"0x1e4aa0b87d10b141\")!\n    return getAuthAccount<auth(BorrowValue) &Account>(vmBridgeAddr)\n        .storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(\n            from: FlowEVMBridgeConfig.coaStoragePath\n        ) ?? panic(\"Could not borrow COA reference\")\n}\n\n\naccess(all)\nstruct TokenInfo {\n    access(all)\n    let address: String\n    access(all)\n    let name: String\n    access(all)\n    let symbol: String\n    access(all)\n    let decimals: UInt8\n    access(all)\n    let totalSupply: UInt256\n    access(all)\n    let pairAddress: String?\n    access(all)\n    let reservedTokenInPair: UInt128\n    access(all)\n    let reservedFlowInPair: UInt128\n\n    init(\n        address: String,\n        name: String,\n        symbol: String,\n        decimals: UInt8,\n        totalSupply: UInt256,\n        pairAddress: String?,\n        reservedTokenInPair: UInt128,\n        reservedFlowInPair: UInt128\n    ) {\n        self.address = address\n        self.name = name\n        self.symbol = symbol\n        self.decimals = decimals\n        self.totalSupply = totalSupply\n        self.pairAddress = pairAddress\n        self.reservedTokenInPair = reservedTokenInPair\n        self.reservedFlowInPair = reservedFlowInPair\n    }\n}\n","import \"AccountsPool\"\nimport \"EVM\"\n\n/// Check if the address belongs to the main account\n///\naccess(all) fun main(\n    mainAddr: Address,\n    address: Address,\n): Bool {\n    let acct = getAuthAccount<auth(Storage) &Account>(mainAddr)\n    if let pool = acct.storage\n        .borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath) {\n        return AccountsPool.isAddressOwnedBy(mainAddr, checkAddress: address)\n    }\n    return false\n}\n","import \"FungibleToken\"\nimport \"EVM\"\nimport \"AccountsPool\"\n\n/// Returns the hex encoded address of the COA in the given Flow address\n///\naccess(all) fun main(\n    mainAddr: Address,\n    userId: String?,\n): AccountInfo? {\n    let acct = getAuthAccount<auth(Storage) &Account>(mainAddr)\n    var flowAddress: Address? = nil\n    if userId == nil {\n        flowAddress = mainAddr\n    } else if let pool = acct.storage\n        .borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath) {\n        flowAddress = pool.getAddress(type: \"eliza\", userId!) ;\n    }\n\n    if flowAddress == nil {\n        return nil\n    }\n\n    var flowBalance: UFix64 = 0.0\n    if let flowVaultRef = getAccount(flowAddress!)\n        .capabilities.get<&{FungibleToken.Balance}>(/public/flowTokenBalance)\n        .borrow() {\n        flowBalance = flowVaultRef.balance\n    }\n\n    var coaAddress: String? = nil\n    var coaBalance: UFix64? = nil\n\n    if let address: EVM.EVMAddress = getAuthAccount<auth(BorrowValue) &Account>(flowAddress!)\n        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)?.address() {\n        let bytes: [UInt8] = []\n        for byte in address.bytes {\n            bytes.append(byte)\n        }\n        coaAddress = String.encodeHex(bytes)\n        coaBalance = address.balance().inFLOW()\n    }\n    return AccountInfo(\n        flowAddress!,\n        flowBalance,\n        coaAddress,\n        coaBalance\n    )\n}\n\naccess(all) struct AccountInfo {\n    access(all) let address: Address\n    access(all) let balance: UFix64\n    access(all) let coaAddress: String?\n    access(all) let coaBalance: UFix64?\n\n    init(\n        _ address: Address,\n        _ balance: UFix64,\n        _ coaAddress: String?,\n        _ coaBalance: UFix64?\n    ) {\n        self.address = address\n        self.balance = balance\n        self.coaAddress = coaAddress\n        self.coaBalance = coaBalance\n    }\n}\n","import \"FungibleToken\"\nimport \"EVM\"\nimport \"AccountsPool\"\n\n/// Returns the hex encoded address of the COA in the given Flow address\n///\naccess(all) fun main(\n    mainAddr: Address,\n): AccountStatus? {\n    if let pool = AccountsPool.borrowAccountsPool(mainAddr) {\n        var flowBalance: UFix64 = 0.0\n        if let flowVaultRef = getAccount(mainAddr)\n            .capabilities.get<&{FungibleToken.Balance}>(/public/flowTokenBalance)\n            .borrow() {\n            flowBalance = flowVaultRef.balance\n        }\n\n        let childrenAmount = pool.getChildrenAmount(type: \"eliza\")\n        return AccountStatus(\n            mainAddr,\n            flowBalance,\n            childrenAmount\n        )\n    }\n    return nil\n}\n\naccess(all) struct AccountStatus {\n    access(all) let address: Address\n    access(all) let balance: UFix64\n    access(all) let childrenAmount: UInt64\n\n    init(\n        _ address: Address,\n        _ balance: UFix64,\n        _ childrenAmount: UInt64\n    ) {\n        self.address = address\n        self.balance = balance\n        self.childrenAmount = childrenAmount\n    }\n}\n","import \"TokenList\"\n\naccess(all)\nfun main(\n    ftAddress: Address,\n    ftContractName: String,\n): Bool {\n    return TokenList.isFungibleTokenRegistered(ftAddress, ftContractName)\n}\n","import \"EVMTokenList\"\n\naccess(all)\nfun main(\n    evmContractAddress: String,\n): Bool {\n    let addrNo0x = evmContractAddress.slice(from: 0, upTo: 2) == \"0x\"\n            ? evmContractAddress.slice(from: 2, upTo: evmContractAddress.length)\n            : evmContractAddress\n    return EVMTokenList.isEVMAddressRegistered(addrNo0x)\n}\n","// Source:\n//\n// This file contains the definitions of the Cadence scripts used in the plugin.\n// The scripts are defined as strings and exported as a dictionary.\n\n// Scripts for prices\nimport getFlowPrice from \"./cadence/scripts/get_flow_price.cdc?raw\";\nimport getStFlowPrice from \"./cadence/scripts/get_stflow_price.cdc?raw\";\nimport getTokenInfoCadence from \"./cadence/scripts/get_flow_token_info.cdc?raw\";\nimport getTokenInfoEVM from \"./cadence/scripts/get_erc20_token_info.cdc?raw\";\n\n// Scripts for account pool\nimport isAddressChildOf from \"./cadence/scripts/account-pool/is_address_child_of_main.cdc?raw\";\nimport getAccountInfoFrom from \"./cadence/scripts/account-pool/get_acct_info_from.cdc?raw\";\nimport getAccountStatus from \"./cadence/scripts/account-pool/get_acct_status.cdc?raw\";\n\n// Scripts for TokenList\nimport isTokenRegistered from \"./cadence/scripts/token-list/is-token-registered.cdc?raw\";\nimport isEVMAssetRegistered from \"./cadence/scripts/token-list/is-evm-asset-registered.cdc?raw\";\n\nexport const scripts = {\n    getFlowPrice,\n    getStFlowPrice,\n    getTokenInfoCadence,\n    getTokenInfoEVM,\n    getAccountInfoFrom,\n    getAccountStatus,\n    isAddressChildOf,\n    isTokenRegistered,\n    isEVMAssetRegistered,\n};\n","import \"EVM\"\nimport \"HybridCustody\"\nimport \"AccountsPool\"\n\n/// Transaction to initialize the agent account\n/// The following resources are required:\n/// - EVM\n/// - HybridCustody.Manager\n/// - AccountsPool\ntransaction() {\n\n    prepare(acct: auth(Storage, Capabilities, Keys) &Account) {\n        // --- Start --- EVM initialization ---\n        let evmStoragePath = StoragePath(identifier: \"evm\")!\n        let evmPublicPath = PublicPath(identifier: \"evm\")!\n        if acct.storage.borrow<&AnyResource>(from: evmStoragePath) == nil {\n            let coa <- EVM.createCadenceOwnedAccount()\n            // Save the COA to the new account\n            acct.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: evmStoragePath)\n        }\n\n        if acct.capabilities.get<&EVM.CadenceOwnedAccount>(evmPublicPath).borrow() == nil {\n            let _ = acct.capabilities.unpublish(evmPublicPath)\n            let addressableCap = acct.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(evmStoragePath)\n            acct.capabilities.publish(addressableCap, at: evmPublicPath)\n        }\n        // --- End --- EVM initialization ---\n\n        // --- Start --- HybridCustody.Manager initialization ---\n        // create account manager with hybrid custody manager capability\n        if acct.storage.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) == nil {\n            let m <- HybridCustody.createManager(filter: nil)\n            acct.storage.save(<- m, to: HybridCustody.ManagerStoragePath)\n        }\n\n        if acct.capabilities.get<&HybridCustody.Manager>(HybridCustody.ManagerPublicPath).borrow() == nil {\n            let _ = acct.capabilities.unpublish(HybridCustody.ManagerPublicPath)\n            acct.capabilities.publish(\n                acct.capabilities.storage.issue<&HybridCustody.Manager>(HybridCustody.ManagerStoragePath),\n                at: HybridCustody.ManagerPublicPath\n            )\n        }\n        // --- End --- HybridCustody.Manager initialization ---\n\n        // --- Start --- AccountsPool initialization ---\n        // create account pool with accounts pool capability\n        if acct.storage.borrow<&AccountsPool.Pool>(from: AccountsPool.StoragePath) == nil {\n            let acctCap = acct.capabilities.storage\n                .issue<auth(HybridCustody.Manage) &HybridCustody.Manager>(HybridCustody.ManagerStoragePath)\n\n            let pool <- AccountsPool.createAccountsPool(acctCap)\n            acct.storage.save(<- pool, to: AccountsPool.StoragePath)\n        }\n\n        if acct.capabilities.get<&AccountsPool.Pool>(AccountsPool.PublicPath).borrow() == nil {\n            let _ = acct.capabilities.unpublish(AccountsPool.PublicPath)\n            acct.capabilities.publish(\n                acct.capabilities.storage.issue<&AccountsPool.Pool>(AccountsPool.StoragePath),\n                at: AccountsPool.PublicPath\n            )\n        }\n        // --- End --- AccountsPool initialization ---\n\n        // --- Start --- Ensure Key is enough ---\n        let firstKey = acct.keys.get(keyIndex: 0) ?? panic(\"No Key 0\")\n        let currentAmount = acct.keys.count\n        let amtToAdd: UInt64 = currentAmount < 50 ? 50 - currentAmount : 0\n\n        var i: UInt64 = 0\n        while i < amtToAdd {\n            acct.keys.add(publicKey: firstKey.publicKey, hashAlgorithm: firstKey.hashAlgorithm, weight: 1000.0)\n            i = i + 1\n        }\n        // --- End --- Ensure Key is enough ---\n    }\n}\n","#allowAccountLinking\nimport \"FungibleToken\"\nimport \"FlowToken\"\nimport \"AccountsPool\"\n\n/// Creates a child account for the given user by the main account\n///\ntransaction(\n    userId: String,\n    initialFundingAmt: UFix64?\n) {\n    let category: String\n    let pool: auth(AccountsPool.Admin) &AccountsPool.Pool\n    let newAcctCap: Capability<auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account>\n\n    prepare(signer: auth(Storage, Capabilities) &Account) {\n        self.category = \"eliza\"\n        self.pool = signer.storage\n            .borrow<auth(AccountsPool.Admin) &AccountsPool.Pool>(from: AccountsPool.StoragePath)\n            ?? panic(\"Could not borrow the pool reference\")\n\n        // create a new Account, no keys needed\n        let newAccount = Account(payer: signer)\n        let fundingAmt = initialFundingAmt ?? 0.01 // Default deposit is 0.01 FLOW to the newly created account\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.storage\n            .borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow reference to the owner's Vault!\")\n        // Withdraw the funding amount from the owner's vault\n        let flowToReserve <- vaultRef.withdraw(amount: fundingAmt)\n\n        // Borrow the new account's Flow Token Receiver reference\n        let newAcctFlowTokenReceiverRef = newAccount.capabilities\n            .get<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n            .borrow()\n            ?? panic(\"Could not borrow receiver reference to the newly created account\")\n        // Deposit the withdrawn FLOW into the new account's vault\n        newAcctFlowTokenReceiverRef.deposit(from: <- flowToReserve)\n\n        /* --- Link the AuthAccount Capability --- */\n        //\n        self.newAcctCap = newAccount.capabilities.account.issue<auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account>()\n    }\n\n    pre {\n        self.pool.getAddress(type: self.category, userId) == nil: \"Account already exists for the given user\"\n    }\n\n    execute {\n        // Setup the new child account\n        self.pool.setupNewChildByKey(type: self.category, key: userId, self.newAcctCap)\n    }\n\n    post {\n        self.pool.getAddress(type: self.category, userId) != nil: \"Account was not created\"\n    }\n}\n","import \"EVM\"\nimport \"FlowEVMBridgeUtils\"\n\nimport \"AccountsPool\"\n\n/// Executes a token transfer to the defined recipient address against the specified ERC20 contract.\n///\ntransaction(\n    evmContractAddressHex: String,\n    recipientAddressHex: String,\n    amount: UInt256,\n    from: String?,\n) {\n\n    let evmContractAddress: EVM.EVMAddress\n    let recipientAddress: EVM.EVMAddress\n    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount\n    let preBalance: UInt256\n    var postBalance: UInt256\n\n    prepare(signer: auth(Storage) &Account) {\n        // ------------- Start - Load the correct Account from signer's Account Pool -------------\n        let acct = (from == nil\n            ? signer\n            : (signer.storage.borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath)\n                ?? panic(\"Failed to load Accounts Pool for \".concat(signer.address.toString()))\n            ).borrowChildAccount(type: \"eliza\", from))\n                ?? panic(\"Could not borrow Account reference for \".concat(from ?? \"signer\"))\n        // ------------- End - Load the correct Account from signer's Account Pool -------------\n\n        self.evmContractAddress = EVM.addressFromString(evmContractAddressHex)\n        self.recipientAddress = EVM.addressFromString(recipientAddressHex)\n\n        self.coa = acct.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)\n            ?? panic(\"Could not borrow CadenceOwnedAccount reference\")\n\n        self.preBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)\n        self.postBalance = 0\n    }\n\n    execute {\n        let calldata = EVM.encodeABIWithSignature(\"transfer(address,uint256)\", [self.recipientAddress, amount])\n        let callResult = self.coa.call(\n            to: self.evmContractAddress,\n            data: calldata,\n            gasLimit: 15_000_000,\n            value: EVM.Balance(attoflow: 0)\n        )\n        assert(callResult.status == EVM.Status.successful, message: \"Call to ERC20 contract failed\")\n        self.postBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)\n    }\n\n    post {\n        self.postBalance == self.preBalance - amount: \"Transfer failed\"\n    }\n}\n","import \"FungibleToken\"\nimport \"FlowToken\"\n\nimport \"EVM\"\n\nimport \"AccountsPool\"\n\n// Transfers $FLOW from the user's account to the recipient's address, determining the target VM based on the format\n// of the recipient's hex address. Note that the sender's funds are sourced by default from the target VM, pulling any\n// difference from the alternate VM if available. e.g. Transfers to Flow addresses will first attempt to withdraw from\n// the user's Flow vault, pulling any remaining funds from the user's EVM account if available. Transfers to EVM\n// addresses will first attempt to withdraw from the user's EVM account, pulling any remaining funds from the user's\n// Flow vault if available. If the user's balance across both VMs is insufficient, the transaction will revert.\n///\n/// @param addressString: The recipient's address in hex format - this should be either an EVM address or a Flow address\n/// @param amount: The amount of $FLOW to transfer as a UFix64 value\n/// @param from: The optional account key to use for the transfer, if the signer is an AccountsPool account\n///\ntransaction(\n    addressString: String,\n    amount: UFix64,\n    from: String?,\n) {\n    let sentVault: @FlowToken.Vault\n    let evmRecipient: EVM.EVMAddress?\n    var receiver: &{FungibleToken.Receiver}?\n\n    prepare(signer: auth(Storage) &Account) {\n        // ------------- Start - Load the correct Account from signer's Account Pool -------------\n        let acct = (from == nil\n            ? signer\n            : (signer.storage.borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath)\n                ?? panic(\"Failed to load Accounts Pool for \".concat(signer.address.toString()))\n            ).borrowChildAccount(type: \"eliza\", from))\n                ?? panic(\"Could not borrow Account reference for \".concat(from ?? \"signer\"))\n        // ------------- End - Load the correct Account from signer's Account Pool -------------\n\n        // Reference account's COA if one exists\n        let coa = acct.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: /storage/evm)\n\n        // Reference account's FlowToken Vault\n        let sourceVault = acct.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow account's FlowToken.Vault\")\n        let cadenceBalance = sourceVault.balance\n\n        // Define optional recipients for both VMs\n        self.receiver = nil\n        let cadenceRecipient = Address.fromString(addressString)\n        self.evmRecipient = cadenceRecipient == nil ? EVM.addressFromString(addressString) : nil\n        // Validate exactly one target address is assigned\n        if cadenceRecipient != nil && self.evmRecipient != nil {\n            panic(\"Malformed recipient address - assignable as both Cadence and EVM addresses\")\n        } else if cadenceRecipient == nil && self.evmRecipient == nil {\n            panic(\"Malformed recipient address - not assignable as either Cadence or EVM address\")\n        }\n\n        // Create empty FLOW vault to capture funds\n        self.sentVault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n        /// If the target VM is Flow, does the Vault have sufficient balance to cover?\n        if cadenceRecipient != nil {\n            // Assign the Receiver of the $FLOW transfer\n            self.receiver = getAccount(cadenceRecipient!).capabilities.borrow<&{FungibleToken.Receiver}>(\n                    /public/flowTokenReceiver\n                ) ?? panic(\"Could not borrow reference to recipient's FungibleToken.Receiver\")\n\n            // Withdraw from the account's Cadence Vault and deposit to sentVault\n            var withdrawAmount = amount < cadenceBalance ? amount : cadenceBalance\n            self.sentVault.deposit(from: <-sourceVault.withdraw(amount: withdrawAmount))\n\n            // If the cadence balance didn't cover the amount, check the account's EVM balance\n            if amount > self.sentVault.balance {\n                let difference = amount - cadenceBalance\n                // Revert if the account doesn't have an EVM account or EVM balance is insufficient\n                if coa == nil || difference < coa!.balance().inFLOW() {\n                    panic(\"Insufficient balance across Flow and EVM accounts\")\n                }\n\n                // Withdraw from the account's EVM account and deposit to sentVault\n                let withdrawFromEVM = EVM.Balance(attoflow: 0)\n                withdrawFromEVM.setFLOW(flow: difference)\n                self.sentVault.deposit(from: <-coa!.withdraw(balance: withdrawFromEVM))\n            }\n        } else if self.evmRecipient != nil {\n            // Check account's balance can cover the amount\n            if coa != nil {\n                // Determine the amount to withdraw from the account's EVM account\n                let balance = coa!.balance()\n                let withdrawAmount = amount < balance.inFLOW() ? amount : balance.inFLOW()\n                balance.setFLOW(flow: withdrawAmount)\n\n                // Withdraw funds from EVM to the sentVault\n                self.sentVault.deposit(from: <-coa!.withdraw(balance: balance))\n            }\n            if amount > self.sentVault.balance {\n                // Insufficient amount withdrawn from EVM, check account's Flow balance\n                let difference = amount - self.sentVault.balance\n                if difference > cadenceBalance {\n                    panic(\"Insufficient balance across Flow and EVM accounts\")\n                }\n                // Withdraw from the account's Cadence Vault and deposit to sentVault\n                self.sentVault.deposit(from: <-sourceVault.withdraw(amount: difference))\n            }\n        }\n    }\n\n    pre {\n        self.sentVault.balance == amount: \"Attempting to send an incorrect amount of $FLOW\"\n    }\n\n    execute {\n        // Complete Cadence transfer if the FungibleToken Receiver is assigned\n        if self.receiver != nil {\n            self.receiver!.deposit(from: <-self.sentVault)\n        } else {\n            // Otherwise, complete EVM transfer\n            self.evmRecipient!.deposit(from: <-self.sentVault)\n        }\n    }\n}\n","import \"FungibleToken\"\nimport \"FungibleTokenMetadataViews\"\n\nimport \"AccountsPool\"\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic FT Transfer with Contract Address and Name\",\n\tdescription: \"Transfer any Fungible Token by providing the contract address and name\",\n\tlanguage: \"en-US\",\n)\n\n/// Can pass in any contract address and name to transfer a token from that contract\n/// This lets you choose the token you want to send\n///\n/// Any contract can be chosen here, so wallets should check argument values\n/// to make sure the intended token contract name and address is passed in\n/// Contracts that are used must implement the FTVaultData Metadata View\n///\n/// Note: This transaction only will work for Fungible Tokens that\n///       have their token's resource name set as \"Vault\".\n///       Tokens with other names will need to use a different transaction\n///       that additionally specifies the identifier\n///\n/// @param amount: The amount of tokens to transfer\n/// @param to: The address to transfer the tokens to\n/// @param contractAddress: The address of the contract that defines the tokens being transferred\n/// @param contractName: The name of the contract that defines the tokens being transferred. Ex: \"FlowToken\"\n/// @param from: The optional account key to use for the transfer, if the signer is an AccountsPool account\n///\ntransaction(\n    amount: UFix64,\n    to: Address,\n    contractAddress: Address,\n    contractName: String,\n    from: String?,\n) {\n\n    // The Vault resource that holds the tokens that are being transferred\n    let tempVault: @{FungibleToken.Vault}\n\n    // FTVaultData struct to get paths from\n    let vaultData: FungibleTokenMetadataViews.FTVaultData\n\n    prepare(signer: auth(Storage) &Account) {\n        // ------------- Start - Load the correct Account from signer's Account Pool -------------\n        let acct = (from == nil\n            ? signer\n            : (signer.storage.borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath)\n                ?? panic(\"Failed to load Accounts Pool for \".concat(signer.address.toString()))\n            ).borrowChildAccount(type: \"eliza\", from))\n                ?? panic(\"Could not borrow Account reference for \".concat(from ?? \"signer\"))\n        // ------------- End - Load the correct Account from signer's Account Pool -------------\n\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow<&{FungibleToken}>(name: contractName)\n                ?? panic(\"Could not borrow FungibleToken reference to the contract. Make sure the provided contract name (\"\n                          .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\n\n        // Use that reference to retrieve the FTView\n        self.vaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?\n            ?? panic(\"Could not resolve FTVaultData view. The \".concat(contractName)\n                .concat(\" contract needs to implement the FTVaultData Metadata view in order to execute this transaction.\"))\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = acct.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: self.vaultData.storagePath)\n\t\t\t?? panic(\"The signer does not store a FungibleToken.Provider object at the path \"\n                .concat(self.vaultData.storagePath.toString()).concat(\"For the \").concat(contractName)\n                .concat(\" contract at address \").concat(contractAddress.toString())\n                .concat(\". The signer must initialize their account with this object first!\"))\n\n        self.tempVault <- vaultRef.withdraw(amount: amount)\n\n        // Get the string representation of the address without the 0x\n        var addressString = contractAddress.toString()\n        if addressString.length == 18 {\n            addressString = addressString.slice(from: 2, upTo: 18)\n        }\n        let typeString: String = \"A.\".concat(addressString).concat(\".\").concat(contractName).concat(\".Vault\")\n        let type = CompositeType(typeString)\n        assert(\n            type != nil,\n            message: \"Could not create a type out of the contract name and address!\"\n        )\n\n        assert(\n            self.tempVault.getType() == type!,\n            message: \"The Vault that was withdrawn to transfer is not the type that was requested!\"\n        )\n    }\n\n    execute {\n        let recipient = getAccount(to)\n        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)\n            ?? panic(\"Could not borrow a Receiver reference to the FungibleToken Vault in account \"\n                .concat(to.toString()).concat(\" at path \").concat(self.vaultData.receiverPath.toString())\n                .concat(\". Make sure you are sending to an address that has \")\n                .concat(\"a FungibleToken Vault set up properly at the specified path.\"))\n\n        // Transfer tokens from the signer's stored vault to the receiver capability\n        receiverRef.deposit(from: <-self.tempVault)\n    }\n}\n","import \"FungibleToken\"\nimport \"FlowToken\"\n\nimport \"ScopedFTProviders\"\nimport \"EVM\"\nimport \"FlowEVMBridgeConfig\"\n\nimport \"TokenList\"\nimport \"NFTList\"\nimport \"EVMTokenList\"\n\nimport \"AccountsPool\"\n\ntransaction(\n    contractAddressHex: String,\n    from: String?,\n) {\n    let scopedProvider: @ScopedFTProviders.ScopedFTProvider\n\n    prepare(signer: auth(Storage, Capabilities) &Account) {\n        // ------------- Start - Load the correct Account from signer's Account Pool -------------\n        let acct = (from == nil\n            ? signer\n            : (signer.storage.borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath)\n                ?? panic(\"Failed to load Accounts Pool for \".concat(signer.address.toString()))\n            ).borrowChildAccount(type: \"eliza\", from))\n                ?? panic(\"Could not borrow Account reference for \".concat(from ?? \"signer\"))\n        // ------------- End - Load the correct Account from signer's Account Pool -------------\n\n        /* --- Configure a ScopedFTProvider - Start -- */\n\n        // Issue and store bridge-dedicated Provider Capability in storage if necessary\n        if acct.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {\n            let providerCap = acct.capabilities\n                .storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(/storage/flowTokenVault)\n            acct.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)\n        }\n        // Copy the stored Provider capability and create a ScopedFTProvider\n        let providerCapCopy = acct.storage\n            .copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(\n                from: FlowEVMBridgeConfig.providerCapabilityStoragePath\n            ) ?? panic(\"Invalid Provider Capability found in storage.\")\n        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)\n        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(\n            provider: providerCapCopy,\n            filters: [ providerFilter ],\n            expiration: getCurrentBlock().timestamp + 1.0\n        )\n        /* --- Configure a ScopedFTProvider - End -- */\n    }\n\n    execute {\n        // Onboard the EVM contract\n        EVMTokenList.ensureEVMAssetRegistered(\n            contractAddressHex,\n            feeProvider: &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n        destroy self.scopedProvider\n    }\n}\n","import \"FungibleToken\"\nimport \"FlowToken\"\n\nimport \"ScopedFTProviders\"\nimport \"FlowEVMBridgeConfig\"\n\nimport \"TokenList\"\nimport \"NFTList\"\nimport \"EVMTokenList\"\n\nimport \"AccountsPool\"\n\ntransaction(\n    address: Address,\n    contractName: String,\n    from: String?,\n) {\n    let scopedProvider: @ScopedFTProviders.ScopedFTProvider\n\n    prepare(signer: auth(Storage, Capabilities) &Account) {\n        // ------------- Start - Load the correct Account from signer's Account Pool -------------\n        let acct = (from == nil\n            ? signer\n            : (signer.storage.borrow<auth(AccountsPool.Child) &AccountsPool.Pool>(from: AccountsPool.StoragePath)\n                ?? panic(\"Failed to load Accounts Pool for \".concat(signer.address.toString()))\n            ).borrowChildAccount(type: \"eliza\", from))\n                ?? panic(\"Could not borrow Account reference for \".concat(from ?? \"signer\"))\n        // ------------- End - Load the correct Account from signer's Account Pool -------------\n\n        /* --- Configure a ScopedFTProvider - Start -- */\n\n        // Issue and store bridge-dedicated Provider Capability in storage if necessary\n        if acct.storage.type(at: FlowEVMBridgeConfig.providerCapabilityStoragePath) == nil {\n            let providerCap = acct.capabilities\n                .storage.issue<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(/storage/flowTokenVault)\n            acct.storage.save(providerCap, to: FlowEVMBridgeConfig.providerCapabilityStoragePath)\n        }\n        // Copy the stored Provider capability and create a ScopedFTProvider\n        let providerCapCopy = acct.storage\n            .copy<Capability<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>>(\n                from: FlowEVMBridgeConfig.providerCapabilityStoragePath\n            ) ?? panic(\"Invalid Provider Capability found in storage.\")\n        let providerFilter = ScopedFTProviders.AllowanceFilter(FlowEVMBridgeConfig.onboardFee)\n        self.scopedProvider <- ScopedFTProviders.createScopedFTProvider(\n            provider: providerCapCopy,\n            filters: [ providerFilter ],\n            expiration: getCurrentBlock().timestamp + 1.0\n        )\n        /* --- Configure a ScopedFTProvider - End -- */\n    }\n\n    execute {\n        EVMTokenList.ensureCadenceAssetRegistered(\n            address,\n            contractName,\n            feeProvider:  &self.scopedProvider as auth(FungibleToken.Withdraw) &{FungibleToken.Provider}\n        )\n        destroy self.scopedProvider\n    }\n}\n","import \"TokenList\"\nimport \"NFTList\"\n\ntransaction(\n    address: Address,\n    contractName: String,\n) {\n    prepare(signer: &Account) {\n        if TokenList.isValidToRegister(address, contractName) {\n            TokenList.ensureFungibleTokenRegistered(address, contractName)\n        } else if NFTList.isValidToRegister(address, contractName) {\n            NFTList.ensureNFTCollectionRegistered(address, contractName)\n        }\n    }\n}\n","// Source:\n//\n// This file contains the definitions of the Cadence transactins used in the plugin.\n// The transactions are defined as strings and exported as a dictionary.\n\nimport initAgentAccount from \"./cadence/transactions/init_agent_account.cdc?raw\";\n// Account Pool related transactions\nimport acctPoolCreateChildAccount from \"./cadence/transactions/account-pool/create_child.cdc?raw\";\nimport acctPoolEVMTransferERC20 from \"./cadence/transactions/account-pool/evm/transfer_erc20_from.cdc?raw\";\nimport acctPoolFlowTokenDynamicTransfer from \"./cadence/transactions/account-pool/flow-token/dynamic_vm_transfer_from.cdc?raw\";\nimport acctPoolFTGenericTransfer from \"./cadence/transactions/account-pool/ft/generic_transfer_with_address_from.cdc?raw\";\n// TokenList related transactions\nimport tlRegisterEVMAsset from './cadence/transactions/account-pool/token-list/register_evm_asset_from.cdc?raw';\nimport tlRegisterCadenceAsset from './cadence/transactions/account-pool/token-list/register_standard_asset_from.cdc?raw';\nimport tlRegisterCadenceAssetNoBridge from './cadence/transactions/token-list/register_standard_asset_no_bridge.cdc?raw';\n\nexport const transactions = {\n    initAgentAccount,\n    acctPoolCreateChildAccount,\n    acctPoolEVMTransferERC20,\n    acctPoolFlowTokenDynamicTransfer,\n    acctPoolFTGenericTransfer,\n    tlRegisterEVMAsset,\n    tlRegisterCadenceAsset,\n    tlRegisterCadenceAssetNoBridge,\n};\n","import { z } from \"zod\";\nimport { injectable } from \"inversify\";\nimport {\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { type ActionOptions, globalContainer, property } from \"@elizaos-plugins/plugin-di\";\nimport { BaseFlowInjectableAction, type ScriptQueryResponse } from \"@elizaos-plugins/plugin-flow\";\nimport { scripts } from \"../assets/scripts.defs\";\n\n/**\n * The generated content for the transfer action\n */\nexport class GetPriceContent {\n    @property({\n        description: \"This field should be FLOW or stFLOW\",\n        examples: [\n            \"If asking for FLOW token, the field should be FLOW\",\n            \"Otherwise, the field should be stFLOW\",\n        ],\n        schema: z.string(),\n    })\n    token: string;\n}\n\n/**\n * The transfer action options\n */\nconst actionOpts: ActionOptions<GetPriceContent> = {\n    name: \"GET_FLOW_PRICE\",\n    similes: [\"GET_STFLOW_PRICE\", \"GET_FLOW_TOKEN_PRICE\", \"GET_STFLOW_TOKEN_PRICE\"],\n    description:\n        \"Call this action to obtain the current price in USD of FLOW token or stFLOW token\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Get current FLOW token price.\",\n                    action: \"GET_FLOW_PRICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Get current stFLOW token price in USD.\",\n                    action: \"GET_STFLOW_PRICE\",\n                },\n            },\n        ],\n    ],\n    contentClass: GetPriceContent,\n    suppressInitialMessage: true,\n};\n\n/**\n * Get price action\n *\n * @category Actions\n * @description Get the current price of FLOW token or stFLOW token\n */\n@injectable()\nexport class GetPriceAction extends BaseFlowInjectableAction<GetPriceContent> {\n    constructor() {\n        super(actionOpts);\n    }\n\n    /**\n     * Validate if the action can be executed\n     */\n    async validate(_runtime: IAgentRuntime, message: Memory, _state?: State): Promise<boolean> {\n        const keywords: string[] = [\"price\", \"flow\", \"stflow\", \"\", \"\"];\n        // Check if the message contains the keywords\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase()),\n        );\n    }\n\n    /**\n     * Execute the transfer action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async execute(\n        content: GetPriceContent | null,\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State,\n        callback?: HandlerCallback,\n    ): Promise<ScriptQueryResponse | null> {\n        if (!content) {\n            elizaLogger.warn(\"No content generated\");\n            return;\n        }\n\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        const resp: ScriptQueryResponse = {\n            ok: false,\n        };\n\n        const targetToken = content.token?.toLowerCase();\n        const validTokens = [\"flow\", \"stflow\"];\n        if (!validTokens.includes(targetToken)) {\n            resp.error = `Invalid token type: ${targetToken}`;\n        } else {\n            let data: string;\n            try {\n                data = await this.walletSerivce.executeScript(\n                    targetToken === \"flow\" ? scripts.getFlowPrice : scripts.getStFlowPrice,\n                    (_arg, _t) => [],\n                    \"\",\n                );\n            } catch (err) {\n                resp.error = err.message;\n            }\n            if (data) {\n                resp.ok = true;\n                resp.data = Number.parseFloat(data);\n            } else {\n                resp.error = resp.error ?? \"Failed to get price data\";\n            }\n        }\n\n        if (resp.ok) {\n            callback?.({\n                text: format(resp.data as number, targetToken),\n                content: {\n                    success: true,\n                    token: content.token,\n                    price: resp.data,\n                },\n                source: \"FlowBlockchain\",\n            });\n        } else {\n            elizaLogger.error(\"Error:\", resp.error);\n            callback?.({\n                text: `Unable to get price for ${content.token}.`,\n                content: {\n                    error: resp.error ?? \"Unknown error\",\n                },\n                source: \"FlowBlockchain\",\n            });\n        }\n\n        elizaLogger.log(`Finished ${this.name} handler.`);\n\n        return resp;\n    }\n}\n\n/**\n * Format the price data\n *\n * @param price the price data\n * @param token the token name\n * @returns the formatted price string\n */\nconst format = (price: number, token: string): string => {\n    return `The current price of ${token} token is $${price.toFixed(8)}`;\n};\n\n// Register the transfer action\nglobalContainer.bind(GetPriceAction).toSelf();\n","import { z } from \"zod\";\nimport { inject, injectable } from \"inversify\";\nimport {\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { type ActionOptions, globalContainer, property } from \"@elizaos-plugins/plugin-di\";\nimport { BaseFlowInjectableAction, CacheProvider, type ScriptQueryResponse } from \"@elizaos-plugins/plugin-flow\";\nimport { scripts } from \"../assets/scripts.defs\";\nimport type { TokenDetailsFromTokenList, TokenInfo } from \"../types\";\n\n/**\n * The generated content for the transfer action\n */\nexport class GetTokenInfoContent {\n    @property({\n        description:\n            \"This field should be the token symbol which usually starts with $ or uppercase letters.\",\n        examples: [\n            \"if a token is named LOPPY or $LOPPY, the field should be LOPPY\",\n            \"if no token symbol is provided, the field should be null\",\n        ],\n        schema: z.string().nullable(),\n    })\n    symbol: string;\n\n    @property({\n        description:\n            \"Cadence Resource Identifier or ERC20 contract address (if not native token). this field should be null if the token is native token which symbol is FLOW.\",\n        examples: [\n            \"For Cadence resource identifier, the field should be 'A.1654653399040a61.ContractName'\",\n            \"For ERC20 contract address, the field should be '0xe6ffc15a5bde7dd33c127670ba2b9fcb82db971a'\",\n        ],\n        schema: z.string().nullable(),\n    })\n    token: string | null;\n\n    @property({\n        description:\n            \"The blockchain VM type. This field should be either 'flow' or 'evm' according to the token type.\",\n        examples: [\n            \"If token field is Cadence resource identifier or null value, the vm field should be 'flow'\",\n            \"If token field is ERC20 contract address, the vm field should be 'evm'\",\n            \"If only symbol field is provided, the vm field should be 'flow'\",\n            \"if symbol field is FLOW or token field is null, the vm field should be 'flow'\",\n        ],\n        schema: z.string().refine((vm) => [\"flow\", \"evm\"].includes(vm)),\n    })\n    vm: \"flow\" | \"evm\";\n}\n\n/**\n * The transfer action options\n */\nconst actionOpts: ActionOptions<GetTokenInfoContent> = {\n    name: \"GET_TOKEN_INFO\",\n    similes: [\"GET_TOKEN_DETAILS\", \"GET_TOKEN_METADATA\"],\n    description:\n        \"Call this action to obtain the current information of any fungible token on the Flow blockchain.\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Get details for the $LOPPY token\",\n                    action: \"GET_TOKEN_INFO\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Get information of $LOPPY token: A.53f389d96fb4ce5e.SloppyStakes\",\n                    action: \"GET_TOKEN_INFO\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Tell me current marketcap of token: 0x995258Cea49C25595CD94407FaD9E99B81406A84\",\n                    action: \"GET_TOKEN_INFO\",\n                },\n            },\n        ],\n    ],\n    contentClass: GetTokenInfoContent,\n    suppressInitialMessage: true,\n};\n\n/**\n * Get price action\n *\n * @category Actions\n * @description Get the current price of FLOW token or stFLOW token\n */\n@injectable()\nexport class GetTokenInfoAction extends BaseFlowInjectableAction<GetTokenInfoContent> {\n    constructor(\n        @inject(CacheProvider)\n        private readonly cache: CacheProvider,\n    ) {\n        super(actionOpts);\n    }\n\n    /**\n     * Validate if the action can be executed\n     */\n    async validate(_runtime: IAgentRuntime, message: Memory, _state?: State): Promise<boolean> {\n        const keywords: string[] = [\n            \"details\",\n            \"token\",\n            \"info\",\n            \"information\",\n            \"mcap\",\n            \"marketcap\",\n            \"\",\n            \"\",\n        ];\n        // Check if the message contains the keywords\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase()),\n        );\n    }\n\n    /**\n     * Execute the transfer action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async execute(\n        content: GetTokenInfoContent | null,\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State,\n        callback?: HandlerCallback,\n    ): Promise<ScriptQueryResponse | null> {\n        if (!content) {\n            elizaLogger.warn(\"No content generated\");\n            return;\n        }\n\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        // Get token list from cache\n        const network = this.walletSerivce.connector.network;\n        const cacheKey = `flow-tokenlist-${network}`\n        const tokenListStr = await this.cache.getCachedData<string>(cacheKey);\n        let tokenList: TokenDetailsFromTokenList[] = [];\n        if (!tokenListStr) {\n            tokenList = await fetchTokenList(network);\n            // 24 hours cache\n            if (tokenList?.length > 0) {\n                await this.cache.setCachedData(cacheKey, JSON.stringify(tokenList), 60 * 60 * 24);\n            }\n        } else {\n            tokenList = JSON.parse(tokenListStr);\n        }\n\n        // Use shared wallet instance\n        const resp: ScriptQueryResponse = {\n            ok: false,\n        };\n\n        let tokenInfo: TokenInfo;\n\n        // if token symbol is FLOW or stFLOW, you cannot get token info\n        const targetToken = content.symbol?.toLowerCase();\n        if ([\"flow\"].includes(targetToken)) {\n            resp.error = \"Cannot get token info for native FLOW token.\";\n        } else {\n            const tokenDetails = tokenList.find((t) =>\n                content.token\n                    ? t.evmAddress === content.token ||\n                      `A.${t.flowAddress}.${t.contractName}` === content.token\n                    : t.symbol === content.symbol,\n            );\n\n            // initialize token info\n            if (tokenDetails) {\n                tokenInfo = {\n                    symbol: tokenDetails.symbol,\n                    name: tokenDetails.name,\n                    description: tokenDetails.description,\n                    decimals: tokenDetails.decimals,\n                    addressEVM: tokenDetails.evmAddress,\n                    identifierCadence: `A.${tokenDetails.flowAddress.slice(2)}.${tokenDetails.contractName}`,\n                    logoURI: tokenDetails.logoURI,\n                    totalSupply: 0,\n                    priceInFLOW: 0,\n                    mcapValueInFLOW: 0,\n                };\n            } else {\n                tokenInfo = {\n                    symbol: content.symbol,\n                    name: \"Unknown\",\n                    description: \"\",\n                    decimals: 0,\n                    addressEVM: undefined,\n                    identifierCadence: undefined,\n                    logoURI: undefined,\n                    totalSupply: 0,\n                    priceInFLOW: 0,\n                    mcapValueInFLOW: 0,\n                };\n            }\n\n            if (content.vm === \"flow\") {\n                tokenInfo.decimals = 8;\n                // if content.vm is flow, tokenDetails should be found\n                if (!tokenDetails) {\n                    resp.error = `Token info not found for $${content.symbol}`;\n                } else {\n                    elizaLogger.debug(`Loading token info for $${content.symbol}:`, tokenDetails);\n                    try {\n                        const info = await this.walletSerivce.executeScript(\n                            scripts.getTokenInfoCadence,\n                            (arg, t) => [\n                                arg(tokenDetails.flowAddress, t.Address),\n                                arg(tokenDetails.contractName, t.String),\n                            ],\n                            undefined,\n                        );\n                        elizaLogger.debug(`Loaded token info for ${content.symbol}:`, info);\n                        if (\n                            info &&\n                            info.address === tokenDetails.flowAddress &&\n                            info.contractName === tokenDetails.contractName\n                        ) {\n                            tokenInfo.totalSupply = Number.parseFloat(info.totalSupply);\n                            tokenInfo.priceInFLOW = Number.parseFloat(info.priceInFLOW);\n                            tokenInfo.mcapValueInFLOW =\n                                tokenInfo.totalSupply * tokenInfo.priceInFLOW;\n\n                            resp.ok = true;\n                            resp.data = tokenInfo;\n                        } else {\n                            resp.error = `Failed to get token info for $${content.symbol}`;\n                        }\n                    } catch (err) {\n                        resp.error = `Failed to get token info for $${content.symbol}: ${err.message}`;\n                    }\n                }\n            } else if (/^0x[0-9a-fA-F]{40}$/.test(content.token ?? \"\")) {\n                // if content.vm is evm, query token info from the blockchain using evm DEX\n                try {\n                    const info = await this.walletSerivce.executeScript(\n                        scripts.getTokenInfoEVM,\n                        (arg, t) => [arg(content.token, t.String)],\n                        undefined,\n                    );\n                    if (info && info.address?.toLowerCase() === content.token.toLowerCase()) {\n                        tokenInfo.name = info.name;\n                        tokenInfo.symbol = info.symbol;\n                        tokenInfo.decimals = Number.parseInt(info.decimals);\n                        tokenInfo.totalSupply =\n                            Number.parseInt(info.totalSupply) / 10 ** tokenInfo.decimals;\n                        const reservedTokenInPair = Number.parseInt(info.reservedTokenInPair);\n                        const reservedFlowInPair = Number.parseInt(info.reservedFlowInPair);\n                        tokenInfo.priceInFLOW = reservedFlowInPair / reservedTokenInPair;\n                        tokenInfo.mcapValueInFLOW = tokenInfo.totalSupply * tokenInfo.priceInFLOW;\n\n                        resp.ok = true;\n                        resp.data = tokenInfo;\n                    }\n                } catch (err) {\n                    resp.error = `Failed to get token info for $${content.symbol}: ${err.message}`;\n                }\n            } else {\n                resp.error = `Invalid token address or identifier: ${content.token}`;\n            }\n        }\n\n        if (resp.ok && resp.data) {\n            callback?.({\n                text: format(resp.data as TokenInfo),\n                content: {\n                    success: true,\n                    tokenInfo,\n                },\n                source: \"FlowBlockchain\",\n            });\n        } else {\n            const errMsg = resp.error ?? resp.errorMessage ?? \"Unknown error\";\n            elizaLogger.error(\"Error:\", errMsg);\n            callback?.({\n                text: `Failed to get token info of $${content.symbol ?? \"UKN\"} - ${content.token}(${content.vm}): ${resp.error}`,\n                content: { error: errMsg },\n                source: \"FlowBlockchain\",\n            });\n        }\n\n        elizaLogger.log(`Finished ${this.name} handler.`);\n\n        return resp;\n    }\n}\n\nconst TOKEN_LIST_REQUEST_URLS = {\n    mainnet: \"https://raw.githubusercontent.com/fixes-world/token-list-jsons/refs/heads/main/jsons/mainnet/flow/reviewers/0xa2de93114bae3e73.json\",\n    testnet: \"https://raw.githubusercontent.com/fixes-world/token-list-jsons/refs/heads/main/jsons/testnet/flow/default.json\",\n};\n\nconst fetchTokenList = async (network: string) => {\n    const jsonUrl = TOKEN_LIST_REQUEST_URLS[network]\n    if (!jsonUrl) { return []; }\n\n    const response = await fetch(jsonUrl);\n    try {\n        const rawdata = await response.json();\n        return rawdata?.tokens ?? [];\n    } catch (error) {\n        elizaLogger.error(\"Error fetching token list:\", error.message);\n    }\n    return [];\n};\n\nconst format = (token: TokenInfo): string => `### Token Details\n\n${token.logoURI?.startsWith(\"http\") ? `![${token.name}](${token.logoURI})` : \"\"}\nSymbol: $${token.symbol}\nName: ${token.name}\nDecimals: ${token.decimals}\nTotal Supply: ${token.totalSupply}\n\nEVM contract address: ${token.addressEVM ?? \"unknown\"}\nCadence identifier: ${token.identifierCadence ?? \"unknown\"}\n\nPrice in FLOW: ${token.priceInFLOW ?? \"unknown\"}\nMarket Cap in FLOW: ${token.mcapValueInFLOW ?? \"unknown\"}\n`;\n\n// Register the transfer action\nglobalContainer.bind(GetTokenInfoAction).toSelf();\n","import { inject, injectable } from \"inversify\";\nimport {\n    elizaLogger,\n    type ActionExample,\n    type Action,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport type { FlowAccountBalanceInfo } from \"@elizaos-plugins/plugin-flow\";\nimport { globalContainer } from \"@elizaos-plugins/plugin-di\";\nimport { FlowWalletService, type TransactionSentResponse } from \"@elizaos-plugins/plugin-flow\";\n\nimport { formater } from \"../helpers\";\nimport { AccountsPoolService } from \"../services/acctPool.service\";\n\n/**\n * Ensure user account exists\n *\n * @category Actions\n * @description Ensure user account exists on Flow blockchain\n */\n@injectable()\nexport class EnsureUserAccountExistsAction implements Action {\n    public readonly name: string;\n    public readonly similes: string[];\n    public readonly description: string;\n    public readonly examples: ActionExample[][];\n    public readonly suppressInitialMessage: boolean;\n\n    constructor(\n        @inject(FlowWalletService)\n        private readonly walletSerivce: FlowWalletService,\n        @inject(AccountsPoolService)\n        private readonly acctPoolService: AccountsPoolService,\n    ) {\n        this.name = \"FETCH_ACCOUNT_INFO\";\n        this.similes = [\n            \"ENSURE_USER_ACCOUNT\",\n            \"ENSURE_USER_ACCOUNT_EXISTS\",\n            \"ENSURE_CHILD_ACCOUNT\",\n            \"ENSURE_CHILD_ACCOUNT_EXISTS\",\n            \"GET_USER_ACCOUNT_INFO\",\n            \"GET_AGENT_ACCOUNT_INFO\",\n        ];\n        this.description = \"Call this action to ensure user or agent's wallet account existing on Flow blockchain, and obtain the current wallet account information of it.\";\n        this.examples = [\n            [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"Create a new wallet for me.\",\n                        action: \"ENSURE_USER_ACCOUNT\",\n                    },\n                },\n            ],\n            [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"Check if I have a wallet, if not, create one.\",\n                        action: \"ENSURE_USER_ACCOUNT\",\n                    },\n                },\n            ],\n            [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"Tell me about my Flow account, if no walelt, please create one.\",\n                        action: \"GET_USER_ACCOUNT_INFO\",\n                    },\n                },\n            ],\n            [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"What's your wallet status?\",\n                    },\n                },\n                {\n                    user: \"{{user2}}\",\n                    content: {\n                        text: \"Let me check my wallet status.\",\n                        action: \"GET_AGENT_ACCOUNT_INFO\",\n                    }\n                }\n            ],\n            [\n                {\n                    user: \"{{user1}}\",\n                    content: {\n                        text: \"What's your balance?\",\n                    },\n                },\n                {\n                    user: \"{{user2}}\",\n                    content: {\n                        text: \"Let me check my wallet status.\",\n                        action: \"GET_AGENT_ACCOUNT_INFO\",\n                    }\n                }\n            ],\n        ];\n        this.suppressInitialMessage = true;\n    }\n\n    /**\n     * Validate if the action can be executed\n     */\n    async validate(_runtime: IAgentRuntime, message: Memory): Promise<boolean> {\n        if (!this.walletSerivce.isInitialized) {\n            return false;\n        }\n\n        const content =\n            typeof message.content === \"string\" ? message.content : message.content?.text;\n\n        if (!content) return false;\n\n        const keywords: string[] = [\"create\", \"wallet\", \"account\", \"info\", \"balance\", \"status\", \"\", \"\", \"\", \"\", \"\"];\n        // Check if the message contains the keywords\n        return keywords.some((keyword) => content.toLowerCase().includes(keyword.toLowerCase()));\n    }\n\n    /**\n     * Execute the transfer action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async handler(\n        runtime: IAgentRuntime,\n        message: Memory,\n        _state?: State,\n        _options?: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) {\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        const content =\n            typeof message.content === \"string\" ? message.content : message.content?.text;\n        const keywords = [\"you\", \"your\", \"agent\", \"agent's\", \"\", \"\", \"\"];\n        const isQueryAgent = keywords.some((keyword) => content.toLowerCase().includes(keyword));\n\n        const userId = message.userId;\n        const isSelf = message.userId === runtime.agentId || isQueryAgent;\n        const mainAddr = this.walletSerivce.address;\n\n        const accountName = `Account[${mainAddr}/${isSelf ? \"root\" : userId}]`;\n\n        let acctInfo: FlowAccountBalanceInfo;\n        try {\n            elizaLogger.debug(\"Querying account info for\", accountName);\n            acctInfo = await this.acctPoolService.queryAccountInfo(isSelf ? null : userId);\n        } catch (e) {\n            elizaLogger.error(\"Error:\", e);\n            callback?.({\n                text: `Unable to fetch info for ${accountName}.`,\n                content: { error: e.message },\n                source: \"FlowBlockchain\",\n            });\n            return;\n        }\n\n        if (acctInfo) {\n            callback?.({\n                text: isSelf\n                    ? formater.formatAgentWalletInfo(runtime.character, acctInfo)\n                    : formater.formatWalletInfo(userId, accountName, acctInfo),\n                content: { success: true, exists: true, info: acctInfo },\n                source: \"FlowBlockchain\",\n            });\n            return;\n        }\n\n        // create a new account by sendinng transaction\n        type TransactionResponse = {\n            txId: string;\n            keyIndex: number;\n            address: string;\n        };\n\n        try {\n            const resp = await new Promise<TransactionResponse>((resolve, reject) => {\n                let txResp: TransactionSentResponse;\n                this.acctPoolService\n                    .createNewAccount(userId, {\n                        onFinalized: async (txId, status, errorMsg) => {\n                            if (errorMsg) {\n                                reject(new Error(`Error in the creation transaction: ${errorMsg}`));\n                                return;\n                            }\n                            const addressCreateEvt = status.events.find(\n                                (e) => e.type === \"flow.AccountCreated\",\n                            );\n                            if (addressCreateEvt) {\n                                const address = addressCreateEvt.data.address;\n                                elizaLogger.log(`Account created for ${userId} at ${address}`);\n                                resolve({\n                                    txId: txResp?.txId ?? txId,\n                                    keyIndex: txResp?.index,\n                                    address: address,\n                                });\n                            } else {\n                                reject(new Error(\"No account created event found.\"));\n                            }\n                        },\n                    })\n                    .then((tx) => {\n                        txResp = tx;\n                    })\n                    .catch((e) => reject(e));\n            });\n            callback?.({\n                text: formater.formatWalletCreated(message.userId, accountName, resp.address),\n                content: resp,\n                source: \"FlowBlockchain\",\n            });\n        } catch (e) {\n            callback?.({\n                text: `Failed to create account for ${accountName}, maybe the account already exists.`,\n                content: { error: e.message },\n                source: \"FlowBlockchain\",\n            });\n        }\n\n        elizaLogger.log(`Completed ${this.name} handler.`);\n    }\n}\n\n// Register the transfer action\nglobalContainer.bind(EnsureUserAccountExistsAction).toSelf();\n","import { inject, injectable } from \"inversify\";\nimport { z } from \"zod\";\nimport {\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { property, globalContainer, type ActionOptions } from \"@elizaos-plugins/plugin-di\";\nimport {\n    isCadenceIdentifier,\n    isEVMAddress,\n    BaseFlowInjectableAction,\n    type TransactionCallbacks,\n    type TransactionSentResponse,\n} from \"@elizaos-plugins/plugin-flow\";\nimport { formater } from \"../helpers\";\nimport { scripts } from \"../assets/scripts.defs\";\nimport { transactions } from \"../assets/transactions.defs\";\n\n/**\n * The generated content for the transfer action\n */\nexport class Content {\n    @property({\n        description:\n            \"Cadence Resource Identifier or ERC20 contract address (if not native token).\",\n        examples: [\n            \"For Cadence resource identifier, the field should be 'A.1654653399040a61.ContractName'\",\n            \"For ERC20 contract address, the field should be '0xe6ffc15a5bde7dd33c127670ba2b9fcb82db971a'\",\n        ],\n        schema: z.string(),\n    })\n    token: string;\n\n    @property({\n        description:\n            \"The blockchain VM type. This field should be either 'flow' or 'evm' according to the token type.\",\n        examples: [\n            \"If token field is Cadence resource identifier, the vm field should be 'flow'\",\n            \"If token field is ERC20 contract address, the vm field should be 'evm'\",\n        ],\n        schema: z.string().refine((vm) => [\"flow\", \"evm\"].includes(vm)),\n    })\n    vm: \"flow\" | \"evm\";\n\n    @property({\n        description:\n            \"The bridging requirement. If user mentioned the token doesn't need to be bridged, set this field to false. Default is true.\",\n        examples: [],\n        schema: z.boolean().default(true),\n    })\n    bridging: boolean;\n}\n\n/**\n * The transfer action options\n */\nconst option: ActionOptions<Content> = {\n    name: \"ENSURE_TOKEN_REGISTERED\",\n    similes: [\n        \"ENSURE_NFT_REGISTERED\",\n        \"REGISTER_TOKEN\",\n        \"REGISTER_NFT\",\n        \"REGISTER_FT\",\n    ],\n    description:\n        \"Call this action to ensure any fungible token/coin or non-fungible token(NFT) be registered in the TokenList on Flow blockchain.\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Register token A.1654653399040a61.FlowToken, no need to bridge\",\n                    action: \"ENSURE_TOKEN_REGISTERED\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Register token 0xb73bf8e6a4477a952e0338e6cc00cc0ce5ad04ba to Tokenlist\",\n                    action: \"ENSURE_TOKEN_REGISTERED\",\n                },\n            },\n        ],\n    ],\n    contentClass: Content,\n    suppressInitialMessage: true,\n};\n\n/**\n * Ensure token registered in TokenList\n *\n * @category Actions\n * @description Ensure token registered in TokenList on Flow blockchain\n */\n@injectable()\nexport class EnsureTokenRegisteredAction extends BaseFlowInjectableAction<Content> {\n    constructor() {\n        super(option);\n    }\n\n    /**\n     * Validate if the action can be executed\n     */\n    async validate(_runtime: IAgentRuntime, message: Memory): Promise<boolean> {\n        if (!this.walletSerivce.isInitialized) {\n            return false;\n        }\n\n        const content =\n            typeof message.content === \"string\" ? message.content : message.content?.text;\n\n        if (!content) return false;\n\n        const keywords: string[] = [\"token\", \"register\", \"tokenlist\", \"token-list\", \"nftlist\", \"nft-list\"];\n        // Check if the message contains the keywords\n        return keywords.some((keyword) => content.toLowerCase().includes(keyword.toLowerCase()));\n    }\n\n    /**\n     * Execute the action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async execute(\n        content: Content | null,\n        runtime: IAgentRuntime,\n        message: Memory,\n        _state?: State,\n        callback?: HandlerCallback,\n    ) {\n        if (!content) {\n            elizaLogger.warn(\"No content generated\");\n            return;\n        }\n\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        const userId = message.userId;\n        const isSelf = message.userId === runtime.agentId;\n        const mainAddr = this.walletSerivce.address;\n\n        const accountName = `Account[${mainAddr}/${isSelf ? \"root\" : userId}]`;\n\n        // Check if token is registered\n        let isRegistered = false;\n        let errorMsg: string | undefined = undefined;\n        let address: string;\n        let contractName: string;\n        if (isCadenceIdentifier(content.token) && content.vm === \"flow\") {\n            const [_, tokenAddr, tokenContractName] = content.token.split(\".\");\n            address = `0x${tokenAddr}`;\n            contractName = tokenContractName;\n\n            elizaLogger.debug(\n                `${accountName}\\n Check A.${tokenAddr}.${tokenContractName} in TokenList...`,\n            );\n\n            try {\n                isRegistered = await this.walletSerivce.executeScript(scripts.isTokenRegistered, (arg, t) => [\n                    arg(address, t.Address),\n                    arg(contractName, t.String),\n                ], false)\n            } catch (e) {\n                elizaLogger.error(\"Error in checking token registration:\", e);\n                errorMsg = e.message;\n            }\n        } else if (isEVMAddress(content.token) && content.vm === \"evm\") {\n            elizaLogger.debug(\n                `${accountName}\\n Check ${content.token} in EVMTokenList...`,\n            );\n            address = content.token;\n\n            try {\n                isRegistered = await this.walletSerivce.executeScript(scripts.isEVMAssetRegistered, (arg, t) => [\n                    arg(content.token.toLowerCase(), t.String),\n                ], false)\n            } catch (e) {\n                elizaLogger.error(\"Error in checking token registration:\", e);\n                errorMsg = e.message;\n            }\n        } else {\n            errorMsg = `Invalid token format or wrong VM type: ${content.token} (${content.vm})`;\n        }\n\n        // if error occurred, return the error message\n        if (errorMsg) {\n            callback?.({\n                text: `Unable to fetch info for ${content.token}.`,\n                content: { error: errorMsg },\n                source: \"FlowBlockchain\",\n            });\n            return;\n        }\n\n        if (isRegistered) {\n            callback?.({\n                text: `Token ${content.token} is already registered in TokenList.`,\n                content: { exists: true },\n                source: \"FlowBlockchain\",\n            });\n            return;\n        }\n\n        type RegisterTokenResponse = {\n            success: boolean;\n            txid: string;\n            evmBridged: boolean;\n            from: string;\n            flowSpent: number;\n            gasFeeSpent: number;\n        }\n\n        // Register the token\n        try {\n            const resp = await new Promise<RegisterTokenResponse>((resolve, reject) => {\n                const transactionCallbacks: TransactionCallbacks = {\n                    onFinalized: async (txId, status, errorMsg) => {\n                        if (errorMsg) {\n                            reject(new Error(`Error in the creation transaction: ${errorMsg}`));\n                            return;\n                        }\n\n                        const validEventNames = [\n                            'EVMTokenList.EVMBridgedAssetRegistered',\n                            'TokenList.FungibleTokenRegistered',\n                            'NFTList.NFTCollectionRegistered'\n                        ]\n                        let fromAddress = \"\";\n                        let flowSpent = 0;\n                        let gasFeeSpent = 0;\n                        let hasValidEvent = false;\n                        let evmBridged = false;\n                        for (const evt of status.events) {\n                            // check if the transaction has a valid event\n                            if (!hasValidEvent) {\n                                const [_1, _2, contractName, eventName] = evt.type.split('.');\n                                hasValidEvent = validEventNames.includes(`${contractName}.${eventName}`)\n                            }\n                            // check if the event is FlowToken.TokensWithdrawn from user's account\n                            if (evt.type.endsWith('FlowToken.TokensWithdrawn') && evt.data.from !== this.walletSerivce.address) {\n                                // calculate the flow spent\n                                fromAddress = evt.data.from;\n                                flowSpent += Number.parseFloat(evt.data.amount);\n                            }\n                            // check gas fee spent\n                            if (evt.type.endsWith(\"FlowFees.FeesDeducted\")) {\n                                gasFeeSpent += Number.parseFloat(evt.data.amount);\n                            }\n                            // check if the event is FlowEVMBridge.BridgeDefiningContractDeployed\n                            if (evt.type.endsWith(\"FlowEVMBridge.BridgeDefiningContractDeployed\")) {\n                                evmBridged = true;\n                            }\n                        }\n\n                        if (hasValidEvent) {\n                            elizaLogger.log(`Token registered successfully: ${content.token}`);\n                            resolve({\n                                success: true,\n                                txid: txId,\n                                evmBridged,\n                                from: fromAddress,\n                                flowSpent,\n                                gasFeeSpent,\n                            });\n                        } else {\n                            elizaLogger.log(`Failed to register token: ${content.token}, no valid event found.`);\n                            resolve({\n                                success: false,\n                                txid: txId,\n                                evmBridged,\n                                from: fromAddress,\n                                flowSpent,\n                                gasFeeSpent,\n                            });\n                        }\n                    },\n                }\n\n                // send the transaction to register the token, based on the VM type\n                let transaction: Promise<TransactionSentResponse>;\n\n                if (content.vm === \"flow\") {\n                    if (content.bridging) {\n                        transaction = this.walletSerivce.sendTransaction(\n                            transactions.tlRegisterCadenceAsset,\n                            (arg, t) => [\n                                arg(address, t.Address),\n                                arg(contractName, t.String),\n                                arg(userId, t.String),\n                            ],\n                            transactionCallbacks,\n                        );\n                    } else {\n                        transaction = this.walletSerivce.sendTransaction(\n                            transactions.tlRegisterCadenceAssetNoBridge,\n                            (arg, t) => [\n                                arg(address, t.Address),\n                                arg(contractName, t.String),\n                            ],\n                            transactionCallbacks,\n                        )\n                    }\n                } else {\n                    transaction = this.walletSerivce.sendTransaction(\n                        transactions.tlRegisterEVMAsset,\n                        (arg, t) => [\n                            arg(content.token, t.String),\n                            arg(userId, t.String),\n                        ],\n                        transactionCallbacks,\n                    )\n                }\n                // wait for the transaction to be finalized\n                transaction.catch((e) => reject(e));\n            });\n            // format the flow spent information\n            const flowSpentInfo = formater.formatFlowSpent(resp.from, resp.flowSpent, this.walletSerivce.address, resp.gasFeeSpent);\n            const prefix = `Operator: ${accountName}\\n${flowSpentInfo}\\n`;\n            // return the response to the callback\n            const finalMsg = resp.success\n                    ? `${prefix}\\n  Token ${content.token} registered successfully.`\n                    : resp.evmBridged\n                        ? `${prefix}\\n  Token has just bridged from EVM side, you need send another transaction to register it in TokenList.`\n                        : `${prefix}\\n  Failed to register token, no valid event found.`;\n            callback?.({\n                text: formater.formatTransationSent(resp.txid, this.walletSerivce.connector.network, finalMsg),\n                content: resp,\n                source: \"FlowBlockchain\",\n            });\n        } catch (e) {\n            callback?.({\n                text: `Operator: ${accountName}\\n Failed to register token, Error: ${e.message}`,\n                content: { error: e.message },\n                source: \"FlowBlockchain\",\n            });\n        }\n\n        elizaLogger.log(`Finished ${this.name} handler.`);\n    }\n}\n\n// Register the transfer action\nglobalContainer.bind(EnsureTokenRegisteredAction).toSelf();\n","import type { PluginOptions } from \"@elizaos-plugins/plugin-di\";\nimport { FlowWalletService } from \"@elizaos-plugins/plugin-flow\";\nimport {\n    TransferAction,\n    GetPriceAction,\n    GetTokenInfoAction,\n    EnsureUserAccountExistsAction,\n    EnsureTokenRegisteredAction,\n} from \"./actions\";\nimport { AccountsPoolService } from \"./services/acctPool.service\";\nimport { AccountProvider } from \"./providers/account.provider\";\n\n/**\n * Basic Flow Plugin configuration\n * Required for the plugin to be loaded, will be exported as default\n */\nexport const basicFlowPlugin: PluginOptions = {\n    name: \"flow-basic\",\n    description: \"Flow Plugin for Eliza with accounts management features.\",\n    actions: [\n        TransferAction,\n        GetPriceAction,\n        GetTokenInfoAction,\n        EnsureUserAccountExistsAction,\n        EnsureTokenRegisteredAction,\n    ],\n    providers: [AccountProvider],\n    evaluators: [],\n    services: [FlowWalletService, AccountsPoolService],\n};\n","import { injectable, inject } from \"inversify\";\nimport {\n    elizaLogger,\n    type IAgentRuntime,\n    type Memory,\n    type Provider,\n    type State,\n} from \"@elizaos/core\";\nimport { globalContainer } from \"@elizaos-plugins/plugin-di\";\nimport { AccountsPoolService } from \"../services/acctPool.service\";\nimport { formater } from \"../helpers\";\n\n/**\n * Wallet provider\n */\n@injectable()\nexport class AccountProvider implements Provider {\n    constructor(\n        @inject(AccountsPoolService)\n        private readonly acctPoolService: AccountsPoolService,\n    ) {}\n\n    /**\n     * Eliza provider `get` method\n     * @returns The message to be injected into the context\n     */\n    async get(_runtime: IAgentRuntime, message: Memory, state?: State): Promise<string | null> {\n        const userId = message.userId;\n        // For one session, only inject the wallet info once\n        if (state) {\n            const PROVIDER_SESSION_FLAG = `account-provider-session:${userId}`;\n            if (state[PROVIDER_SESSION_FLAG]) {\n                return null;\n            }\n            state[PROVIDER_SESSION_FLAG] = true;\n        }\n\n        try {\n            const isSelf = message.userId === message.agentId;\n            const acctInfo = await this.acctPoolService.queryAccountInfo(\n                isSelf ? undefined : userId,\n            );\n            const accountName = `Account[${this.acctPoolService.mainAddress}/${isSelf ? \"root\" : userId}]`;\n            return formater.formatWalletInfo(userId, accountName, acctInfo);\n        } catch (error) {\n            elizaLogger.error(\"Error in Account provider:\", error.message);\n        }\n        return null;\n    }\n}\n\n// Wallet provider is bound to request scope\nglobalContainer.bind(AccountProvider).toSelf().inRequestScope();\n","export * from \"./actions\";\nexport * from \"./plugin\";\nexport * from \"./assets/scripts.defs\";\n\nimport { basicFlowPlugin } from \"./plugin\";\n\nexport default basicFlowPlugin;\n"],"mappings":";;;;;;;;AAAA,SAASA,SAAS;AAClB,SAASC,UAAAA,SAAQC,cAAAA,mBAAkB;AACnC,SACIC,eAAAA,oBAKG;AACP,SAA6BC,mBAAAA,kBAAiBC,gBAAgB;AAC9D,SAASC,qBAAqBC,cAAcC,eAAeC,gCAAgC;;;ACV3F;;;;;;;;SACIC,uBACAC,qBACAC,kBACAC,iBACAC,4BACG;;;ACNP,SAASC,YAAYC,cAAc;AACnC,SAASC,aAAaC,eAAqD;AAC3E,SAASC,uBAAuB;AAChC,SACIC,mBACAC,WAAWC,sBAIR;;;ACTP;;;ACAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACoBO,IAAMC,UAAU;EACnBC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;AACJ;;;AC9BA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","names":["z","inject","injectable","elizaLogger","globalContainer","property","isCadenceIdentifier","isEVMAddress","isFlowAddress","BaseFlowInjectableAction","formatAgentWalletInfo","formatWalletCreated","formatWalletInfo","formatFlowSpent","formatTransationSent","injectable","inject","elizaLogger","Service","globalContainer","FlowWalletService","queries","defaultQueries","scripts","getFlowPrice","getStFlowPrice","getTokenInfoCadence","getTokenInfoEVM","getAccountInfoFrom","getAccountStatus","isAddressChildOf","isTokenRegistered","isEVMAssetRegistered","transactions","initAgentAccount","acctPoolCreateChildAccount","acctPoolEVMTransferERC20","acctPoolFlowTokenDynamicTransfer","acctPoolFTGenericTransfer","tlRegisterEVMAsset","tlRegisterCadenceAsset","tlRegisterCadenceAssetNoBridge","AccountsPoolService","Service","constructor","walletService","serviceType","initialize","_runtime","status","getMainAccountStatus","Promise","resolve","reject","sendTransaction","transactions","initAgentAccount","_arg","_t","onFinalized","txid","_status","errorMsg","elizaLogger","error","Error","info","catch","mainAddress","address","walletAddress","obj","executeScript","scripts","getAccountStatus","arg","t","Address","undefined","balance","Number","parseFloat","childrenAmount","parseInt","checkAddressIsChildOfAgent","isAddressChildOf","queryAccountInfo","userId","getAccountInfoFrom","Optional","String","coaAddress","coaBalance","createNewAccount","callbacks","initalFunding","acctPoolCreateChildAccount","toFixed","UFix64","transferFlowToken","fromUserId","recipient","amount","acctPoolFlowTokenDynamicTransfer","transferGenericFT","tokenFTAddr","tokenContractName","acctPoolFTGenericTransfer","transferERC20","erc20Contract","decimals","defaultQueries","queryEvmERC20Decimals","wallet","adjustedAmount","BigInt","acctPoolEVMTransferERC20","toString","UInt256","globalContainer","bind","toSelf","inSingletonScope","TransferContent","token","amount","to","description","examples","schema","z","string","nullable","union","number","transferOption","name","similes","user","content","text","action","contentClass","suppressInitialMessage","isUUID","str","uuidRegex","test","TransferAction","BaseFlowInjectableAction","constructor","acctPoolService","validate","runtime","message","state","execute","_runtime","_state","callback","elizaLogger","warn","log","walletAddress","walletSerivce","address","userId","isSelf","agentId","logPrefix","Number","parseFloat","recipient","Error","acctInfo","queryAccountInfo","info","txId","keyIndex","fromAccountInfo","totalBalance","balance","coaBalance","resp","transferFlowToken","index","isCadenceIdentifier","isFlowAddress","_","tokenAddr","tokenContractName","split","transferGenericFT","isEVMAddress","transferERC20","tokenName","extraMsg","formater","formatTransationSent","wallet","network","success","txid","e","error","globalContainer","bind","toSelf","z","injectable","elizaLogger","globalContainer","property","BaseFlowInjectableAction","GetPriceContent","token","description","examples","schema","z","string","actionOpts","name","similes","user","content","text","action","contentClass","suppressInitialMessage","GetPriceAction","BaseFlowInjectableAction","constructor","validate","_runtime","message","_state","keywords","some","keyword","toLowerCase","includes","execute","_message","callback","elizaLogger","warn","log","resp","ok","targetToken","validTokens","error","data","walletSerivce","executeScript","scripts","getFlowPrice","getStFlowPrice","_arg","_t","err","Number","parseFloat","format","success","price","source","toFixed","globalContainer","bind","toSelf","z","inject","injectable","elizaLogger","globalContainer","property","BaseFlowInjectableAction","CacheProvider","GetTokenInfoContent","symbol","token","vm","description","examples","schema","z","string","nullable","refine","includes","actionOpts","name","similes","user","content","text","action","contentClass","suppressInitialMessage","GetTokenInfoAction","BaseFlowInjectableAction","constructor","cache","validate","_runtime","message","_state","keywords","some","keyword","toLowerCase","execute","_message","callback","elizaLogger","warn","log","network","walletSerivce","connector","cacheKey","tokenListStr","getCachedData","tokenList","fetchTokenList","length","setCachedData","JSON","stringify","parse","resp","ok","tokenInfo","targetToken","error","tokenDetails","find","t","evmAddress","flowAddress","contractName","decimals","addressEVM","identifierCadence","slice","logoURI","totalSupply","priceInFLOW","mcapValueInFLOW","undefined","debug","info","executeScript","scripts","getTokenInfoCadence","arg","Address","String","address","Number","parseFloat","data","err","test","getTokenInfoEVM","parseInt","reservedTokenInPair","reservedFlowInPair","format","success","source","errMsg","errorMessage","TOKEN_LIST_REQUEST_URLS","mainnet","testnet","jsonUrl","response","fetch","rawdata","json","tokens","startsWith","globalContainer","bind","toSelf","inject","injectable","elizaLogger","globalContainer","FlowWalletService","EnsureUserAccountExistsAction","name","similes","description","examples","suppressInitialMessage","constructor","walletSerivce","acctPoolService","user","content","text","action","validate","_runtime","message","isInitialized","keywords","some","keyword","toLowerCase","includes","handler","runtime","_state","_options","callback","elizaLogger","log","isQueryAgent","userId","isSelf","agentId","mainAddr","address","accountName","acctInfo","debug","queryAccountInfo","e","error","source","formater","formatAgentWalletInfo","character","formatWalletInfo","success","exists","info","resp","Promise","resolve","reject","txResp","createNewAccount","onFinalized","txId","status","errorMsg","Error","addressCreateEvt","events","find","type","data","keyIndex","index","then","tx","catch","formatWalletCreated","globalContainer","bind","toSelf","injectable","z","elizaLogger","property","globalContainer","isCadenceIdentifier","isEVMAddress","BaseFlowInjectableAction","Content","token","vm","bridging","description","examples","schema","z","string","refine","includes","boolean","default","option","name","similes","user","content","text","action","contentClass","suppressInitialMessage","EnsureTokenRegisteredAction","BaseFlowInjectableAction","constructor","validate","_runtime","message","walletSerivce","isInitialized","keywords","some","keyword","toLowerCase","execute","runtime","_state","callback","elizaLogger","warn","log","userId","isSelf","agentId","mainAddr","address","accountName","isRegistered","errorMsg","undefined","contractName","isCadenceIdentifier","_","tokenAddr","tokenContractName","split","debug","executeScript","scripts","isTokenRegistered","arg","t","Address","String","e","error","isEVMAddress","isEVMAssetRegistered","source","exists","resp","Promise","resolve","reject","transactionCallbacks","onFinalized","txId","status","Error","validEventNames","fromAddress","flowSpent","gasFeeSpent","hasValidEvent","evmBridged","evt","events","_1","_2","eventName","type","endsWith","data","from","Number","parseFloat","amount","success","txid","transaction","sendTransaction","transactions","tlRegisterCadenceAsset","tlRegisterCadenceAssetNoBridge","tlRegisterEVMAsset","catch","flowSpentInfo","formater","formatFlowSpent","prefix","finalMsg","formatTransationSent","connector","network","globalContainer","bind","toSelf","FlowWalletService","injectable","inject","elizaLogger","globalContainer","AccountProvider","constructor","acctPoolService","get","_runtime","message","state","userId","PROVIDER_SESSION_FLAG","isSelf","agentId","acctInfo","queryAccountInfo","undefined","accountName","mainAddress","formater","formatWalletInfo","error","elizaLogger","globalContainer","bind","toSelf","inRequestScope","basicFlowPlugin","name","description","actions","TransferAction","GetPriceAction","GetTokenInfoAction","EnsureUserAccountExistsAction","EnsureTokenRegisteredAction","providers","AccountProvider","evaluators","services","FlowWalletService","AccountsPoolService","basicFlowPlugin"]}